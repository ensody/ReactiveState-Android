{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ReactiveState for Kotlin Multiplatform and Android \u00b6 Easy reactive state management for Kotlin Multiplatform. No boilerplate. Compatible with Android. ReactiveState-Kotlin provides these foundations: reactive programming : everything is recomputed/updated automatically based on straightforward code demand-driven programming : resource-consuming computations and values are allocated on-demand and disposed when not needed multiplatform : share your ViewModels and reactive state handling logic between all platforms event handling : simple events based on interfaces (more composable and less boilerplate than sealed classes) automatic error catching : no more forgotten try-catch or copy-pasted error handling logic all over the place coroutine-based unit tests : worry no more about passing around CoroutineDispatcher s everywhere lifecycle handling state restoration See the ReactiveState documentation for more details. Supported platforms \u00b6 android, jvm, ios, tvos, watchos, macosX64, linuxX64, js Installation \u00b6 Add the package to your build.gradle \u2018s dependencies {} : dependencies { // Add the BOM using the desired ReactiveState version api platform ( \"com.ensody.reactivestate:reactivestate-bom:VERSION\" ) // Leave out the version number from now on: implementation \"com.ensody.reactivestate:reactivestate\" // Utils for unit tests that want to use coroutines implementation \"com.ensody.reactivestate:reactivestate-test\" // Note: kotlin-coroutines-test only supports the \"jvm\" target, // so reactivestate-test has the same limitation } Also, make sure you\u2019ve integrated the Maven Central repo, e.g. in your root build.gradle : subprojects { repositories { // ... mavenCentral () // ... } } Quick intro \u00b6 The following two principles are here to give you a quick idea of the reactive programming aspect only. The \u201cGuide\u201d section in the documentation describes how to work with the more advanced aspects like multiplatform ViewModels, lifecycle handling, etc. Note: While the discussion is about StateFlow , you can also use LiveData or even implement extensions for other observable values. Observing StateFlow \u00b6 Imagine you have an input form with first and last name and want to observe two StateFlow values at the same time: isFirstNameValid: StateFlow<Boolean> isLastNameValid: StateFlow<Boolean> This is how you\u2019d do it by using the autoRun function: autoRun { submitButton . isEnabled = get ( isFirstNameValid ) && get ( isLastNameValid ) } With get(isFirstNameValid) you retrieve isFirstNameValid.value and at the same time tell autoRun to re-execute the block whenever the value is changed. That code is similar to writing this: lifecycleScope . launchWhenStarted { isFirstNameValid . combine ( isLastNameValid ) { firstNameValid , lastNameValid -> firstNameValid to lastNameValid } . conflate () . collect { ( firstNameValid , lastNameValid ) -> try { submitButton . isEnabled = firstNameValid && lastNameValid } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { onError ( e ) } } } Reactive StateFlow / reactive data \u00b6 The same principle can be used to create a derived , reactive StateFlow : val isFormValid : StateFlow < Boolean > = derived { get ( isFirstNameValid ) && get ( isLastNameValid ) } Now you can use autoRun { submitButton.isEnabled = get(isFormValid) } in the rest of your code. Going even further, isFirstNameValid itself would usually also be the result of a derived computation. So, you can have multiple layers of reactive derived StateFlow s. Relation to Jetpack Compose / Flutter / React \u00b6 Reactive UI frameworks like Jetpack Compose automatically rebuild the UI whenever e.g. a StateFlow changes. Isn\u2019t that the same thing as autoRun already? Do you still need this library? If you look closely at the code sample above, the ViewModel uses derived to automatically recompute a StateFlow based on other StateFlow s. This pattern is very useful in practice and provides the perfect foundation for frameworks like Jetpack Compose which only focus on the UI aspect. Actually, Jetpack Compose is like derived for the UI. ReactiveState\u2019s derived and autoRun provide the same reactivity for your data and business logic. So, the combination of both solutions used together results in a fully reactive codebase - which improves code simplicity and avoids many bugs. Moreover, Jetpack Compose currently doesn\u2019t provide any multiplatform ViewModel support or any large-scale architecture. So, this library solves this by providing BaseReactiveState for ViewModels. This comes with a lifecycle-aware event system ( eventNotifier ) and loading state handling (so you can track one or multiple different loading indicators based on coroutines that you launch). See also \u00b6 This library is based on reactive_state for Flutter and adapted to Kotlin Multiplatform and Android patterns. License \u00b6 Copyright 2020-2021 Ensody GmbH, Waldemar Kornewald Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#reactivestate-for-kotlin-multiplatform-and-android","text":"Easy reactive state management for Kotlin Multiplatform. No boilerplate. Compatible with Android. ReactiveState-Kotlin provides these foundations: reactive programming : everything is recomputed/updated automatically based on straightforward code demand-driven programming : resource-consuming computations and values are allocated on-demand and disposed when not needed multiplatform : share your ViewModels and reactive state handling logic between all platforms event handling : simple events based on interfaces (more composable and less boilerplate than sealed classes) automatic error catching : no more forgotten try-catch or copy-pasted error handling logic all over the place coroutine-based unit tests : worry no more about passing around CoroutineDispatcher s everywhere lifecycle handling state restoration See the ReactiveState documentation for more details.","title":"ReactiveState for Kotlin Multiplatform and Android"},{"location":"#supported-platforms","text":"android, jvm, ios, tvos, watchos, macosX64, linuxX64, js","title":"Supported platforms"},{"location":"#installation","text":"Add the package to your build.gradle \u2018s dependencies {} : dependencies { // Add the BOM using the desired ReactiveState version api platform ( \"com.ensody.reactivestate:reactivestate-bom:VERSION\" ) // Leave out the version number from now on: implementation \"com.ensody.reactivestate:reactivestate\" // Utils for unit tests that want to use coroutines implementation \"com.ensody.reactivestate:reactivestate-test\" // Note: kotlin-coroutines-test only supports the \"jvm\" target, // so reactivestate-test has the same limitation } Also, make sure you\u2019ve integrated the Maven Central repo, e.g. in your root build.gradle : subprojects { repositories { // ... mavenCentral () // ... } }","title":"Installation"},{"location":"#quick-intro","text":"The following two principles are here to give you a quick idea of the reactive programming aspect only. The \u201cGuide\u201d section in the documentation describes how to work with the more advanced aspects like multiplatform ViewModels, lifecycle handling, etc. Note: While the discussion is about StateFlow , you can also use LiveData or even implement extensions for other observable values.","title":"Quick intro"},{"location":"#observing-stateflow","text":"Imagine you have an input form with first and last name and want to observe two StateFlow values at the same time: isFirstNameValid: StateFlow<Boolean> isLastNameValid: StateFlow<Boolean> This is how you\u2019d do it by using the autoRun function: autoRun { submitButton . isEnabled = get ( isFirstNameValid ) && get ( isLastNameValid ) } With get(isFirstNameValid) you retrieve isFirstNameValid.value and at the same time tell autoRun to re-execute the block whenever the value is changed. That code is similar to writing this: lifecycleScope . launchWhenStarted { isFirstNameValid . combine ( isLastNameValid ) { firstNameValid , lastNameValid -> firstNameValid to lastNameValid } . conflate () . collect { ( firstNameValid , lastNameValid ) -> try { submitButton . isEnabled = firstNameValid && lastNameValid } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { onError ( e ) } } }","title":"Observing StateFlow"},{"location":"#reactive-stateflow-reactive-data","text":"The same principle can be used to create a derived , reactive StateFlow : val isFormValid : StateFlow < Boolean > = derived { get ( isFirstNameValid ) && get ( isLastNameValid ) } Now you can use autoRun { submitButton.isEnabled = get(isFormValid) } in the rest of your code. Going even further, isFirstNameValid itself would usually also be the result of a derived computation. So, you can have multiple layers of reactive derived StateFlow s.","title":"Reactive StateFlow / reactive data"},{"location":"#relation-to-jetpack-compose-flutter-react","text":"Reactive UI frameworks like Jetpack Compose automatically rebuild the UI whenever e.g. a StateFlow changes. Isn\u2019t that the same thing as autoRun already? Do you still need this library? If you look closely at the code sample above, the ViewModel uses derived to automatically recompute a StateFlow based on other StateFlow s. This pattern is very useful in practice and provides the perfect foundation for frameworks like Jetpack Compose which only focus on the UI aspect. Actually, Jetpack Compose is like derived for the UI. ReactiveState\u2019s derived and autoRun provide the same reactivity for your data and business logic. So, the combination of both solutions used together results in a fully reactive codebase - which improves code simplicity and avoids many bugs. Moreover, Jetpack Compose currently doesn\u2019t provide any multiplatform ViewModel support or any large-scale architecture. So, this library solves this by providing BaseReactiveState for ViewModels. This comes with a lifecycle-aware event system ( eventNotifier ) and loading state handling (so you can track one or multiple different loading indicators based on coroutines that you launch).","title":"Relation to Jetpack Compose / Flutter / React"},{"location":"#see-also","text":"This library is based on reactive_state for Flutter and adapted to Kotlin Multiplatform and Android patterns.","title":"See also"},{"location":"#license","text":"Copyright 2020-2021 Ensody GmbH, Waldemar Kornewald Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 4.2.1 \u00b6 Fixed recursively changing the value of a MutableValueFlow from within the collect block (change->emit->change). Previously this could lead to a deadlock because the first change is still locking the MutableValueFLow . 4.2.0 \u00b6 Added OnReactiveStateAttached interface to allow customizing by reactiveState behavior. 4.1.0 \u00b6 Added MutableValueFlow<Int>.incrementFrom(flow: StateFlow<Int>) extension function to e.g. sum multiple loading states into one MutableValueFlow<Int> . 4.0.0 \u00b6 This release adds support for Kotlin Multiplatform and introduces a multiplatform ReactiveState ViewModel. Breaking changes: The modules have been restructured and renamed: reactivestate-bom (previously dependency-versions-bom) reactivestate (previously core and reactivestate) reactivestate-test (previously core-test) CoroutineTestRule is now a simple class that you can either derive from or add as an attribute. CoroutineTest has become independent of JUnit and inherits from CoroutineTestRule . The coroutineTestRule attribute has been replaced with direct testCoroutineScope and testCoroutineDispatcher attributes inherited from the new CoroutineTestRule . The withLoading concept in autoRun , CoroutineLauncher etc. has become more flexible to allow tracking separate loading states. Removed ReducingStateFlow as part of the simplified loading state concept. Non-breaking changes: Added a multiplatform ViewModel ReactiveState (interface), BaseReactiveState (base class). This is actually a broader concept that can be used for any living object that can launch coroutines, automatically handles errors, triggers events, and tracks loading states. Added a multiplatform buildViewModel extension function for creating such a ViewModel on an Activity and Fragment. Improved automatic error catching for autoRun and derived . Fixes for lifecycle observers: onCreate , onCreateView , onCreateViewOnce , onDestroyView , onDestroyViewOnce . MutableValueFlow.replaceLocked returns the previous value now. Known limitations which will be solved with later releases: On non-JVM platforms, dispatchers.io currently equals Dispatchers.Default . This primarily affects MutableValueFlow : Internally, all uses of the JVM-only synchronized have been replaced with a spinlock Mutex since they were only utilized for very tiny blocks of code which normally don\u2019t even have any parallel access. Be careful about doing too large computations in combination with highly concurrent updates via replaceLocked , though. Changelog of preview releases: 4.0.0-dev.4: Fixed build failures due to Jacoco integration. 4.0.0-dev.3: Removed ReducingStateFlow . Publish iOS/macOS builds. 4.0.0-dev.2: Improved automatic error catching for autoRun and derived . Fixes for lifecycle observers Removed LoadingStateTracker . Replaced CoroutineLauncher.isAnyLoading and generalLoading with a simple loading: MutableValueFlow<Int> . MutableValueFlow.replaceLocked returns the previous value now. MutableValueFlow.increment / decrement now have an optional amount argument to increment by more than 1. Also, they return the previous value. 4.0.0-dev.1: This preview release comes without macOS/iOS builds. A port of the CI pipeline is in progress. 3.9.0 \u00b6 Added @ExperimentalReactiveStateApi annotation to mark experimental APIs. Explicitly marked SuspendMutableValueFlow as experimental and changed its constructor to take the default value instead of a delegating MutableValueFlow . Turned SuspendMutableValueFlow into an interface and constructor/factory function. 3.8.3 \u00b6 Fixed argument inconsistency in SuspendMutableValueFlow.replace . 3.8.2 \u00b6 Fixed state restoration with SavedStateHandleStore . 3.8.1 \u00b6 Fixed support for nullable values in SavedStateHandleStore . 3.8.0 \u00b6 Added by propertyName and by lazyProperty helpers simplifying ReadOnlyProperty . 3.7.0 \u00b6 MutableValueFlow \u2018s constructor now optionally takes a setter lambda function which is executed before emitting a new value. This allows observing / reacting to changes without needing a CoroutineScope . Added val Fragment/Activity.savedInstanceState helper which gives you access to a StateFlowStore where you can put saved instance state. Added by stateFlowViewModel helpers which work like by stateViewModel but use a StateFlowStore . Added by Fragment/Activity.savedInstanceState(default) and by StateFlowStore.getData(default) and extension function which automatically uses a key based on the property name. SavedStateHandleStore now provides an alternative constructor with doesn\u2019t require a CoroutineScope and only has one-way MutableValueFlow -> LiveData sync (which covers the 99% use-case). 3.6.0 \u00b6 Added SuspendMutableValueFlow for values that must be mutated via a suspend fun. 3.5.0 \u00b6 The lambda function for WhileUsed now receives a WhileUsedReferenceToken which has a lazy scope attribute in case you need a CoroutineScope with the same lifetime as your WhileUsed value. Fixed withLoading behavior of first derived calculation. 3.4.0 \u00b6 Added buildOnViewModel which allows creating arbitrary objects living on an internally-created wrapper ViewModel. Added MutableStateFlow.replace and MutableValueFlow.replaceLocked helper functions for simplifying e.g. data class copy() based mutation. 3.3.0 \u00b6 Added NamespacedStateFlowStore . Added ReducingStateFlow . 3.2.1 \u00b6 Moved from JCenter to Maven Central ( JCenter is shutting down ). Make sure your repositories block looks like this: repositories { google () mavenCentral () // ... } 3.2.0 \u00b6 CoroutineTest now implements AttachedDisposables and disposes at the end of runBlockingTest . CoroutineTest provides collectFlow to easily collect a derived with WhileSubscribed() in background. 3.1.1 \u00b6 Fixed withErrorReporting to really accept a suspension function. 3.1.0 \u00b6 Added withErrorReporting to handle suspension functions and optional onError . Added EventNotifier.handleEvents helpers for Kotlin and Android. The Android version takes a LifecycleOwner . Added EventNotifierTest . 3.0.0 \u00b6 Breaking changes: IMPORTANT: In order to overcome a limitation, the flowTransformer argument of derived / coAutoRun / CoAutoRunner must now map over lambda functions and execute them. E.g.: mapLatest { it() } . Without the it() no value will ever be recomputed! The default flowTransformer has changed from { mapLatest { } } to { conflatedWorker() } . There is also latestWorker if you want the old behavior. The possible arguments to derived were changed a little bit in order to improve compatibility with WhileUsed . Either you must remove the started: SharingStarted argument or additionally pass an initial value. If you leave out the started argument derived behaves like before when passing Eagerly : the value is computed immediately and synchronously and you can\u2019t call suspend functions within the observer. Otherwise, you have to pass an initial value. In this case, derived is asynchronous and you can call suspend functions within the observer. The default value for started is now Eagerly because that has better safety guarantees. So, in most usages the whole argument can now be removed (except where you really need WhileSubscribed() , for example). Removed bindings because they turned out to not be useful enough. Resolver.track() now returns the AutoRunnerObservable instead of the underlyingObservable . Non-breaking changes: Added WhileUsed for reference-counted singletons that get garbage-collected when all consumers\u2019 CoroutineScope s end. Added conflatedWorker , latestWorker and debouncedWorker as simple flowTransformer s for the suspend-based derived / coAutoRun . Added conflatedMap helper for mapping first and last elements and - whenever possible - intermediate elements. Added simple ErrorEvents interface and withErrorReporting(eventNotifier) { ... } for easy error handling. MutableFlow.tryEmit now returns a Boolean . Legal change: Switched license to Apache 2.0. 2.0.4 \u00b6 Upgraded dependencies (coroutines 1.4.3, androidx.lifecycle 2.3.0, fragment-ktx 1.3.1) 2.0.2 \u00b6 Fixed BOM (reactivestate was missing). 2.0.0 \u00b6 Breaking changes: Moved all Android-related code to the com.ensody.reactivestate.android package to avoid method resolution ambiguity. Removed CoroutineScopeOwner (replaced by CoroutineLauncher ). Non-breaking changes: Added CoroutineLauncher interface to allow overriding how autoRun / derived launch their coroutines (e.g. to include custom error handling or a loading state). Added coAutoRun and CoAutoRunner and derived variants which take suspension functions and use mapLatest . 1.1.0 \u00b6 StateFlowStore.getData() now returns a MutableValueFlow 1.0.0 \u00b6 derived now takes a mandatory started: SharingStarted argument - similar to stateIn / shareIn ( WhileSubscribed() , Lazily , Eagerly , etc.) 0.15.4 \u00b6 Fixed CoroutineTest . 0.15.3 \u00b6 Added support for using CoroutineTest by delegation (preventing multiple inheritance situations). 0.15.2 \u00b6 Added buildViewModel and stateViewModel extension functions for Activity . 0.15.0 \u00b6 derived supports an optional lazy = true argument to observe lazily. Added a global dispatchers API for replacing Dispatchers ( Main , IO , etc.) in a way that allows switching to TestCoroutineDispatcher in unit tests. Added coroutine unit test helpers in the com.ensody.reactivestate:core-test module: CoroutineTest base class for tests that use coroutines. This sets up MainScope , dispatchers.io , etc. to use TestCoroutineDispatcher . CoroutineTestRule a test rule for setting up coroutines. CoroutineTestRuleOwner a helper interface in case you can\u2019t use CoroutineTest , but still want minimal boilerplate. Removed launchWhileStarted and launchWhileResumed . Added dependency-versions-bom platform project. You can now include the versions of all modules like this: dependencies { // Add the BOM using the desired ReactiveState version api platform ( \"com.ensody.reactivestate:dependency-versions-bom:VERSION\" ) // Now you can leave out the version number from all other ReactiveState modules: implementation \"com.ensody.reactivestate:core\" // For Kotlin-only projects implementation \"com.ensody.reactivestate:reactivestate\" // For Android projects implementation \"com.ensody.reactivestate:core-test\" // Utils for unit tests that want to use coroutines } 0.14.0 \u00b6 Fixed MutableValueFlow.value assignment to have distinctUntilChanged behavior. This should provide the best of both worlds: emit / tryEmit / update always emit .value behaves exactly like with MutableStateFlow 0.13.0 \u00b6 After a long period of tuning the API and use at several companies this release introduces the hopefully last set of major breaking changes. This is the final migration to Flow -based APIs like StateFlow / SharedFlow / ValueFlow and removal of obsolete APIs. autoRun now auto-disposes in Activity.onDestroy / Fragment.onDestroyView , so usually it should be launched in Activity.onCreate() / Fragment.onCreateView() (previously onStart() ). It still automatically observes only between onStart() / onStop() . Removed MutableLiveDataNonNull and other non-null LiveData helpers. Use MutableStateFlow and MutableValueFlow instead. Added MutableValueFlow which implements MutableStateFlow , but doesn\u2019t have distinctUntilChanged behavior and offers an in-place update { it.attr = ... } method. This makes it safer and easier to use with mutable values. Removed DerivedLiveData . Use DerivedStateFlow / derived instead. Replaced workQueue with the much simpler EventNotifier which allows sending one-time events to the UI. Replaced Scoped with a simple CoroutineScopeOwner interface. Upgraded to Kotlin 1.4.10. 0.12.0 \u00b6 Breaking changes (migration to StateFlow ): derived now returns a StateFlow instead of a LiveData , so you can use derived in multiplatform code. LiveDataStore has been replaced with StateFlowStore , so you can write multiplatform code. InMemoryStore has been replaced with InMemoryStateFlowStore . SavedStateHandleStore now implements StateFlowStore and requires a CoroutineScope in addition to SavedStateHandle . State has been renamed to Scoped (more descriptive). Other changes: Added StateFlow -based API for bindings. The LiveData -based API is still available. 0.11.4 \u00b6 Switched to api instead of implementation for most dependencies. 0.11.3 \u00b6 Fixed edge case with autoRun on LiveData incorrectly ignoring the first notification. 0.11.2 \u00b6 Fixed release packaging of Android reactivestate package. 0.11 \u00b6 ATTENTION: There\u2019s a breaking change to support StateFlow . Added experimental StateFlow support to autoRun ( StateFlow was added in kotlinx-coroutines-core 1.3.6). Breaking change: Removed CoroutineContext.autoRun and suspend fun autoRun because proper StateFlow support requires access to a CoroutineScope . 0.10 \u00b6 Added thisWorkQueue helper for passing an arg via this . argWorkQueue now supports suspension functions. Added AttachedDisposables interface for objects that can clean up other disposables. AutoRunner now implements AttachedDisposables . Added OnDispose { ... } class for triggering a function when its dispose() method is called. Added onDestroyView { ... } , onDestroy , onCreate , onCreateView and their ...Once variants. Added validUntil for properties that are only valid during a lifecycle subset. Further documentation improvements. 0.9.1 \u00b6 This release introduces no code changes. Fixed release publication on jcenter. Minor documentation improvements. 0.9 \u00b6 ATTENTION: Due to the core & reactivestate module split you have to also add the core module to your dependencies as described in the installation instructions . This release splits the reactivestate module into a Kotlin module ( core ) and an Android module ( reactivestate ). The change is backwards-compatible unless you\u2019ve accessed BaseAutoRunner (very unlikely). Added State base class for separating business logic from ViewModel , making it easier to use in normal unit tests. Added argWorkQueue , arg-based consume and consumeConflated helpers for ViewModel -> UI event/notification use-case. Fixed one-level recursion when observing LiveData . Documentation improvements. 0.8 \u00b6 ATTENTION: This release comes with a few breaking changes. Bindings don\u2019t have value converters, anymore. Usually you need to store the raw field value and a separate conversion (if possible without errors), anyway. Use autoRun or derived to convert values. Added bindings for CompoundButton (replacing CheckBox bindings). AutoRunner \u2018s and autoRun \u2018s observer callback now receives the Resolver via this instead of as an argument (more consistent and compact code). You can write get(livedata) to retrieve a LiveData value. AutoRunner \u2018s and autoRun \u2018s onChange callback now receives the AutoRunner as its first argument. Improved AutoRunner \u2018s null handling of LiveData . Added onResume , onResumeOnce , onPause , onPauseOnce , launchWhileResumed lifecycle observers. Added Disposable.disposeOnCompletionOf(coroutineContext) extension methods. Added WorkQueue and helpers like conflatedWorkQueue for simpler communication between UI and ViewModel. Added unit tests. Added simple documentation with API reference. 0.5 \u00b6 Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#421","text":"Fixed recursively changing the value of a MutableValueFlow from within the collect block (change->emit->change). Previously this could lead to a deadlock because the first change is still locking the MutableValueFLow .","title":"4.2.1"},{"location":"changelog/#420","text":"Added OnReactiveStateAttached interface to allow customizing by reactiveState behavior.","title":"4.2.0"},{"location":"changelog/#410","text":"Added MutableValueFlow<Int>.incrementFrom(flow: StateFlow<Int>) extension function to e.g. sum multiple loading states into one MutableValueFlow<Int> .","title":"4.1.0"},{"location":"changelog/#400","text":"This release adds support for Kotlin Multiplatform and introduces a multiplatform ReactiveState ViewModel. Breaking changes: The modules have been restructured and renamed: reactivestate-bom (previously dependency-versions-bom) reactivestate (previously core and reactivestate) reactivestate-test (previously core-test) CoroutineTestRule is now a simple class that you can either derive from or add as an attribute. CoroutineTest has become independent of JUnit and inherits from CoroutineTestRule . The coroutineTestRule attribute has been replaced with direct testCoroutineScope and testCoroutineDispatcher attributes inherited from the new CoroutineTestRule . The withLoading concept in autoRun , CoroutineLauncher etc. has become more flexible to allow tracking separate loading states. Removed ReducingStateFlow as part of the simplified loading state concept. Non-breaking changes: Added a multiplatform ViewModel ReactiveState (interface), BaseReactiveState (base class). This is actually a broader concept that can be used for any living object that can launch coroutines, automatically handles errors, triggers events, and tracks loading states. Added a multiplatform buildViewModel extension function for creating such a ViewModel on an Activity and Fragment. Improved automatic error catching for autoRun and derived . Fixes for lifecycle observers: onCreate , onCreateView , onCreateViewOnce , onDestroyView , onDestroyViewOnce . MutableValueFlow.replaceLocked returns the previous value now. Known limitations which will be solved with later releases: On non-JVM platforms, dispatchers.io currently equals Dispatchers.Default . This primarily affects MutableValueFlow : Internally, all uses of the JVM-only synchronized have been replaced with a spinlock Mutex since they were only utilized for very tiny blocks of code which normally don\u2019t even have any parallel access. Be careful about doing too large computations in combination with highly concurrent updates via replaceLocked , though. Changelog of preview releases: 4.0.0-dev.4: Fixed build failures due to Jacoco integration. 4.0.0-dev.3: Removed ReducingStateFlow . Publish iOS/macOS builds. 4.0.0-dev.2: Improved automatic error catching for autoRun and derived . Fixes for lifecycle observers Removed LoadingStateTracker . Replaced CoroutineLauncher.isAnyLoading and generalLoading with a simple loading: MutableValueFlow<Int> . MutableValueFlow.replaceLocked returns the previous value now. MutableValueFlow.increment / decrement now have an optional amount argument to increment by more than 1. Also, they return the previous value. 4.0.0-dev.1: This preview release comes without macOS/iOS builds. A port of the CI pipeline is in progress.","title":"4.0.0"},{"location":"changelog/#390","text":"Added @ExperimentalReactiveStateApi annotation to mark experimental APIs. Explicitly marked SuspendMutableValueFlow as experimental and changed its constructor to take the default value instead of a delegating MutableValueFlow . Turned SuspendMutableValueFlow into an interface and constructor/factory function.","title":"3.9.0"},{"location":"changelog/#383","text":"Fixed argument inconsistency in SuspendMutableValueFlow.replace .","title":"3.8.3"},{"location":"changelog/#382","text":"Fixed state restoration with SavedStateHandleStore .","title":"3.8.2"},{"location":"changelog/#381","text":"Fixed support for nullable values in SavedStateHandleStore .","title":"3.8.1"},{"location":"changelog/#380","text":"Added by propertyName and by lazyProperty helpers simplifying ReadOnlyProperty .","title":"3.8.0"},{"location":"changelog/#370","text":"MutableValueFlow \u2018s constructor now optionally takes a setter lambda function which is executed before emitting a new value. This allows observing / reacting to changes without needing a CoroutineScope . Added val Fragment/Activity.savedInstanceState helper which gives you access to a StateFlowStore where you can put saved instance state. Added by stateFlowViewModel helpers which work like by stateViewModel but use a StateFlowStore . Added by Fragment/Activity.savedInstanceState(default) and by StateFlowStore.getData(default) and extension function which automatically uses a key based on the property name. SavedStateHandleStore now provides an alternative constructor with doesn\u2019t require a CoroutineScope and only has one-way MutableValueFlow -> LiveData sync (which covers the 99% use-case).","title":"3.7.0"},{"location":"changelog/#360","text":"Added SuspendMutableValueFlow for values that must be mutated via a suspend fun.","title":"3.6.0"},{"location":"changelog/#350","text":"The lambda function for WhileUsed now receives a WhileUsedReferenceToken which has a lazy scope attribute in case you need a CoroutineScope with the same lifetime as your WhileUsed value. Fixed withLoading behavior of first derived calculation.","title":"3.5.0"},{"location":"changelog/#340","text":"Added buildOnViewModel which allows creating arbitrary objects living on an internally-created wrapper ViewModel. Added MutableStateFlow.replace and MutableValueFlow.replaceLocked helper functions for simplifying e.g. data class copy() based mutation.","title":"3.4.0"},{"location":"changelog/#330","text":"Added NamespacedStateFlowStore . Added ReducingStateFlow .","title":"3.3.0"},{"location":"changelog/#321","text":"Moved from JCenter to Maven Central ( JCenter is shutting down ). Make sure your repositories block looks like this: repositories { google () mavenCentral () // ... }","title":"3.2.1"},{"location":"changelog/#320","text":"CoroutineTest now implements AttachedDisposables and disposes at the end of runBlockingTest . CoroutineTest provides collectFlow to easily collect a derived with WhileSubscribed() in background.","title":"3.2.0"},{"location":"changelog/#311","text":"Fixed withErrorReporting to really accept a suspension function.","title":"3.1.1"},{"location":"changelog/#310","text":"Added withErrorReporting to handle suspension functions and optional onError . Added EventNotifier.handleEvents helpers for Kotlin and Android. The Android version takes a LifecycleOwner . Added EventNotifierTest .","title":"3.1.0"},{"location":"changelog/#300","text":"Breaking changes: IMPORTANT: In order to overcome a limitation, the flowTransformer argument of derived / coAutoRun / CoAutoRunner must now map over lambda functions and execute them. E.g.: mapLatest { it() } . Without the it() no value will ever be recomputed! The default flowTransformer has changed from { mapLatest { } } to { conflatedWorker() } . There is also latestWorker if you want the old behavior. The possible arguments to derived were changed a little bit in order to improve compatibility with WhileUsed . Either you must remove the started: SharingStarted argument or additionally pass an initial value. If you leave out the started argument derived behaves like before when passing Eagerly : the value is computed immediately and synchronously and you can\u2019t call suspend functions within the observer. Otherwise, you have to pass an initial value. In this case, derived is asynchronous and you can call suspend functions within the observer. The default value for started is now Eagerly because that has better safety guarantees. So, in most usages the whole argument can now be removed (except where you really need WhileSubscribed() , for example). Removed bindings because they turned out to not be useful enough. Resolver.track() now returns the AutoRunnerObservable instead of the underlyingObservable . Non-breaking changes: Added WhileUsed for reference-counted singletons that get garbage-collected when all consumers\u2019 CoroutineScope s end. Added conflatedWorker , latestWorker and debouncedWorker as simple flowTransformer s for the suspend-based derived / coAutoRun . Added conflatedMap helper for mapping first and last elements and - whenever possible - intermediate elements. Added simple ErrorEvents interface and withErrorReporting(eventNotifier) { ... } for easy error handling. MutableFlow.tryEmit now returns a Boolean . Legal change: Switched license to Apache 2.0.","title":"3.0.0"},{"location":"changelog/#204","text":"Upgraded dependencies (coroutines 1.4.3, androidx.lifecycle 2.3.0, fragment-ktx 1.3.1)","title":"2.0.4"},{"location":"changelog/#202","text":"Fixed BOM (reactivestate was missing).","title":"2.0.2"},{"location":"changelog/#200","text":"Breaking changes: Moved all Android-related code to the com.ensody.reactivestate.android package to avoid method resolution ambiguity. Removed CoroutineScopeOwner (replaced by CoroutineLauncher ). Non-breaking changes: Added CoroutineLauncher interface to allow overriding how autoRun / derived launch their coroutines (e.g. to include custom error handling or a loading state). Added coAutoRun and CoAutoRunner and derived variants which take suspension functions and use mapLatest .","title":"2.0.0"},{"location":"changelog/#110","text":"StateFlowStore.getData() now returns a MutableValueFlow","title":"1.1.0"},{"location":"changelog/#100","text":"derived now takes a mandatory started: SharingStarted argument - similar to stateIn / shareIn ( WhileSubscribed() , Lazily , Eagerly , etc.)","title":"1.0.0"},{"location":"changelog/#0154","text":"Fixed CoroutineTest .","title":"0.15.4"},{"location":"changelog/#0153","text":"Added support for using CoroutineTest by delegation (preventing multiple inheritance situations).","title":"0.15.3"},{"location":"changelog/#0152","text":"Added buildViewModel and stateViewModel extension functions for Activity .","title":"0.15.2"},{"location":"changelog/#0150","text":"derived supports an optional lazy = true argument to observe lazily. Added a global dispatchers API for replacing Dispatchers ( Main , IO , etc.) in a way that allows switching to TestCoroutineDispatcher in unit tests. Added coroutine unit test helpers in the com.ensody.reactivestate:core-test module: CoroutineTest base class for tests that use coroutines. This sets up MainScope , dispatchers.io , etc. to use TestCoroutineDispatcher . CoroutineTestRule a test rule for setting up coroutines. CoroutineTestRuleOwner a helper interface in case you can\u2019t use CoroutineTest , but still want minimal boilerplate. Removed launchWhileStarted and launchWhileResumed . Added dependency-versions-bom platform project. You can now include the versions of all modules like this: dependencies { // Add the BOM using the desired ReactiveState version api platform ( \"com.ensody.reactivestate:dependency-versions-bom:VERSION\" ) // Now you can leave out the version number from all other ReactiveState modules: implementation \"com.ensody.reactivestate:core\" // For Kotlin-only projects implementation \"com.ensody.reactivestate:reactivestate\" // For Android projects implementation \"com.ensody.reactivestate:core-test\" // Utils for unit tests that want to use coroutines }","title":"0.15.0"},{"location":"changelog/#0140","text":"Fixed MutableValueFlow.value assignment to have distinctUntilChanged behavior. This should provide the best of both worlds: emit / tryEmit / update always emit .value behaves exactly like with MutableStateFlow","title":"0.14.0"},{"location":"changelog/#0130","text":"After a long period of tuning the API and use at several companies this release introduces the hopefully last set of major breaking changes. This is the final migration to Flow -based APIs like StateFlow / SharedFlow / ValueFlow and removal of obsolete APIs. autoRun now auto-disposes in Activity.onDestroy / Fragment.onDestroyView , so usually it should be launched in Activity.onCreate() / Fragment.onCreateView() (previously onStart() ). It still automatically observes only between onStart() / onStop() . Removed MutableLiveDataNonNull and other non-null LiveData helpers. Use MutableStateFlow and MutableValueFlow instead. Added MutableValueFlow which implements MutableStateFlow , but doesn\u2019t have distinctUntilChanged behavior and offers an in-place update { it.attr = ... } method. This makes it safer and easier to use with mutable values. Removed DerivedLiveData . Use DerivedStateFlow / derived instead. Replaced workQueue with the much simpler EventNotifier which allows sending one-time events to the UI. Replaced Scoped with a simple CoroutineScopeOwner interface. Upgraded to Kotlin 1.4.10.","title":"0.13.0"},{"location":"changelog/#0120","text":"Breaking changes (migration to StateFlow ): derived now returns a StateFlow instead of a LiveData , so you can use derived in multiplatform code. LiveDataStore has been replaced with StateFlowStore , so you can write multiplatform code. InMemoryStore has been replaced with InMemoryStateFlowStore . SavedStateHandleStore now implements StateFlowStore and requires a CoroutineScope in addition to SavedStateHandle . State has been renamed to Scoped (more descriptive). Other changes: Added StateFlow -based API for bindings. The LiveData -based API is still available.","title":"0.12.0"},{"location":"changelog/#0114","text":"Switched to api instead of implementation for most dependencies.","title":"0.11.4"},{"location":"changelog/#0113","text":"Fixed edge case with autoRun on LiveData incorrectly ignoring the first notification.","title":"0.11.3"},{"location":"changelog/#0112","text":"Fixed release packaging of Android reactivestate package.","title":"0.11.2"},{"location":"changelog/#011","text":"ATTENTION: There\u2019s a breaking change to support StateFlow . Added experimental StateFlow support to autoRun ( StateFlow was added in kotlinx-coroutines-core 1.3.6). Breaking change: Removed CoroutineContext.autoRun and suspend fun autoRun because proper StateFlow support requires access to a CoroutineScope .","title":"0.11"},{"location":"changelog/#010","text":"Added thisWorkQueue helper for passing an arg via this . argWorkQueue now supports suspension functions. Added AttachedDisposables interface for objects that can clean up other disposables. AutoRunner now implements AttachedDisposables . Added OnDispose { ... } class for triggering a function when its dispose() method is called. Added onDestroyView { ... } , onDestroy , onCreate , onCreateView and their ...Once variants. Added validUntil for properties that are only valid during a lifecycle subset. Further documentation improvements.","title":"0.10"},{"location":"changelog/#091","text":"This release introduces no code changes. Fixed release publication on jcenter. Minor documentation improvements.","title":"0.9.1"},{"location":"changelog/#09","text":"ATTENTION: Due to the core & reactivestate module split you have to also add the core module to your dependencies as described in the installation instructions . This release splits the reactivestate module into a Kotlin module ( core ) and an Android module ( reactivestate ). The change is backwards-compatible unless you\u2019ve accessed BaseAutoRunner (very unlikely). Added State base class for separating business logic from ViewModel , making it easier to use in normal unit tests. Added argWorkQueue , arg-based consume and consumeConflated helpers for ViewModel -> UI event/notification use-case. Fixed one-level recursion when observing LiveData . Documentation improvements.","title":"0.9"},{"location":"changelog/#08","text":"ATTENTION: This release comes with a few breaking changes. Bindings don\u2019t have value converters, anymore. Usually you need to store the raw field value and a separate conversion (if possible without errors), anyway. Use autoRun or derived to convert values. Added bindings for CompoundButton (replacing CheckBox bindings). AutoRunner \u2018s and autoRun \u2018s observer callback now receives the Resolver via this instead of as an argument (more consistent and compact code). You can write get(livedata) to retrieve a LiveData value. AutoRunner \u2018s and autoRun \u2018s onChange callback now receives the AutoRunner as its first argument. Improved AutoRunner \u2018s null handling of LiveData . Added onResume , onResumeOnce , onPause , onPauseOnce , launchWhileResumed lifecycle observers. Added Disposable.disposeOnCompletionOf(coroutineContext) extension methods. Added WorkQueue and helpers like conflatedWorkQueue for simpler communication between UI and ViewModel. Added unit tests. Added simple documentation with API reference.","title":"0.8"},{"location":"changelog/#05","text":"Initial release.","title":"0.5"},{"location":"demand-driven-programming/","text":"Demand-driven programming \u00b6 Demand-driven means that expensive resources are automatically (on-demand) only allocated as long as they\u2019re needed and then freed when not needed. This also includes computations which should only happen when they\u2019re needed. For example, by lazy is not demand-driven because it only allocates resources on first use, but never deallocates. However, stateIn together with WhileSubscribed allows creating a demand-driven StateFlow that might e.g. communicate with a backend via a WebSocket (let\u2019s say a news ticker). Normally you want to only keep the connection open as long as there is some UI that displays the data. Once the user logs out or switches to some other screen or just locks his screen you want to close the connection. The point of being demand-driven is to make this automatic, so your code becomes 100% robust and simple, no matter in which way you change your UI. You should never have to plaster your code with explicit open() and close() logic everywhere because in practice this \u201cimperative\u201d logic leads to bugs. Imagine the a new requirement where you want to show the news widget in a few more screens, so now the connection needs to be kept open across some screens, but on others it can be closed. The way to model this problem is that some screens \u201cdemand\u201d the news ticker. In other words, they have a dependency on the news ticker. News ticker example \u00b6 Imagine you want to show the breaking news only, but the backend only provides a list of all latest news. We have to filter the breaking news from that list, but all of that should only happen while the screen is visible. If the user locks the screen or switches the app the connection should stop. class NewsTicker ( scope : CoroutineScope ) { val latestNews : StateFlow < List < News >> = channelFlow { // connect to backend, watch for changes and send() latest news, // and close the connection when the flow is cancelled }. stateIn ( initial = emptyList (), started = WhileSubscribed ()) } // A demand-driven singleton which you can put into your DI val newsTicker = WhileUsed { // it.scope is a MainScope that exists only as long someone depends on newsTicker // and is cancelled once it's not needed anymore. NewsTicker ( it . scope ) } val breakingNews : StateFlow < List < News >> = derived ( initial = emptyList (), started = WhileSubscribed ()) { get ( get ( newsTicker ). latestNews ) . filter { it . isBreakingNews } } class NewsScreen : Fragment () { override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // autoRun only collects in >= STARTED state. // When the user e.g. locks the screen or switches to some other app, // it cancels collecting because the state is < STARTED. autoRun { updateScreen ( get ( breakingNews )) } } fun updateScreen ( news : List < News > ) { // ... } } As you can see, some of this depends on Kotlin\u2019s WhileSubscribed() . WhileUsed allows you to create an on-demand computed singleton that gets disposed as soon as nobody is using it, anymore. Here we\u2019re applying it to only create the NewsTicker object as long as it\u2019s needed. Internally, WhileUsed is tracking the number of reference, so once that \u201creference count\u201d goes back to count == 0 it can destroy its value and CoroutineScope . As an alternative to the autoRun / derived based tracking, you can also use a CoroutineScope to track the dependency lifetime: // This holds the reference until coroutineScope is cancelled. // Note: it's lowercase newsTicker, so we're calling the WhileUsed object here. val newsTickerInstance = newsTicker ( coroutineScope ) If even this doesn\u2019t work for you, there are other alternatives like manual reference count tracking or passing a DisposableGroup .","title":"Demand-driven programming"},{"location":"demand-driven-programming/#demand-driven-programming","text":"Demand-driven means that expensive resources are automatically (on-demand) only allocated as long as they\u2019re needed and then freed when not needed. This also includes computations which should only happen when they\u2019re needed. For example, by lazy is not demand-driven because it only allocates resources on first use, but never deallocates. However, stateIn together with WhileSubscribed allows creating a demand-driven StateFlow that might e.g. communicate with a backend via a WebSocket (let\u2019s say a news ticker). Normally you want to only keep the connection open as long as there is some UI that displays the data. Once the user logs out or switches to some other screen or just locks his screen you want to close the connection. The point of being demand-driven is to make this automatic, so your code becomes 100% robust and simple, no matter in which way you change your UI. You should never have to plaster your code with explicit open() and close() logic everywhere because in practice this \u201cimperative\u201d logic leads to bugs. Imagine the a new requirement where you want to show the news widget in a few more screens, so now the connection needs to be kept open across some screens, but on others it can be closed. The way to model this problem is that some screens \u201cdemand\u201d the news ticker. In other words, they have a dependency on the news ticker.","title":"Demand-driven programming"},{"location":"demand-driven-programming/#news-ticker-example","text":"Imagine you want to show the breaking news only, but the backend only provides a list of all latest news. We have to filter the breaking news from that list, but all of that should only happen while the screen is visible. If the user locks the screen or switches the app the connection should stop. class NewsTicker ( scope : CoroutineScope ) { val latestNews : StateFlow < List < News >> = channelFlow { // connect to backend, watch for changes and send() latest news, // and close the connection when the flow is cancelled }. stateIn ( initial = emptyList (), started = WhileSubscribed ()) } // A demand-driven singleton which you can put into your DI val newsTicker = WhileUsed { // it.scope is a MainScope that exists only as long someone depends on newsTicker // and is cancelled once it's not needed anymore. NewsTicker ( it . scope ) } val breakingNews : StateFlow < List < News >> = derived ( initial = emptyList (), started = WhileSubscribed ()) { get ( get ( newsTicker ). latestNews ) . filter { it . isBreakingNews } } class NewsScreen : Fragment () { override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // autoRun only collects in >= STARTED state. // When the user e.g. locks the screen or switches to some other app, // it cancels collecting because the state is < STARTED. autoRun { updateScreen ( get ( breakingNews )) } } fun updateScreen ( news : List < News > ) { // ... } } As you can see, some of this depends on Kotlin\u2019s WhileSubscribed() . WhileUsed allows you to create an on-demand computed singleton that gets disposed as soon as nobody is using it, anymore. Here we\u2019re applying it to only create the NewsTicker object as long as it\u2019s needed. Internally, WhileUsed is tracking the number of reference, so once that \u201creference count\u201d goes back to count == 0 it can destroy its value and CoroutineScope . As an alternative to the autoRun / derived based tracking, you can also use a CoroutineScope to track the dependency lifetime: // This holds the reference until coroutineScope is cancelled. // Note: it's lowercase newsTicker, so we're calling the WhileUsed object here. val newsTickerInstance = newsTicker ( coroutineScope ) If even this doesn\u2019t work for you, there are other alternatives like manual reference count tracking or passing a DisposableGroup .","title":"News ticker example"},{"location":"error-handling/","text":"Error handling \u00b6 ErrorEvents \u00b6 This library provides a simple base events interface that is used in several places for error handling called ErrorEvents . Here\u2019s the whole implementation interface ErrorEvents { fun onError ( error : Throwable ) } Some of the functionality requires that you implement this interface. EventNotifier \u00b6 Your ViewModels and other classes that can launch their own coroutines somehow have to communicate errors to the UI (or higher-level layers in general). Note: This section only discusses the error-specific aspect of EventNotifier . See Event handling for more general usage of EventNotifier . Imagine this in your business logic or ViewModel: coroutineScope . launch { // someSuspendFun can throw an exception someSuspendFun () } If someSuspendFun() throws an exception, how will you let the user know that there is an error? You need an event queue/dispatcher that is processed by the UI. That\u2019s what EventNotifier is. val eventNotifier = EventNotifier < ErrorEvents > () fun doSomething () { coroutineScope . launch { try { someSuspendFun () } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { // This sends the event via eventNotifier eventNotifier { onError ( e ) } } } } You can simplify that code by using withErrorReporting : val eventNotifier = EventNotifier < ErrorEvents > () fun doSomething () { coroutineScope . launch { withErrorReporting ( eventNotifier ) { someSuspendFun () } } } BaseReactiveState \u00b6 The multiplatform ViewModel base class BaseReactiveState already provides an eventNotifier and a launch function that catches exceptions: class MyViewModel ( scope : CoroutineScope ) : BaseReactiveState < ErrorEvents > ( scope ) { init { launch { // ...code block... } } } This will automatically catch exceptions and trigger eventNotifier { onError(throwable) } . See Multiplatform ViewModels for more details.","title":"Error handling"},{"location":"error-handling/#error-handling","text":"","title":"Error handling"},{"location":"error-handling/#errorevents","text":"This library provides a simple base events interface that is used in several places for error handling called ErrorEvents . Here\u2019s the whole implementation interface ErrorEvents { fun onError ( error : Throwable ) } Some of the functionality requires that you implement this interface.","title":"ErrorEvents"},{"location":"error-handling/#eventnotifier","text":"Your ViewModels and other classes that can launch their own coroutines somehow have to communicate errors to the UI (or higher-level layers in general). Note: This section only discusses the error-specific aspect of EventNotifier . See Event handling for more general usage of EventNotifier . Imagine this in your business logic or ViewModel: coroutineScope . launch { // someSuspendFun can throw an exception someSuspendFun () } If someSuspendFun() throws an exception, how will you let the user know that there is an error? You need an event queue/dispatcher that is processed by the UI. That\u2019s what EventNotifier is. val eventNotifier = EventNotifier < ErrorEvents > () fun doSomething () { coroutineScope . launch { try { someSuspendFun () } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { // This sends the event via eventNotifier eventNotifier { onError ( e ) } } } } You can simplify that code by using withErrorReporting : val eventNotifier = EventNotifier < ErrorEvents > () fun doSomething () { coroutineScope . launch { withErrorReporting ( eventNotifier ) { someSuspendFun () } } }","title":"EventNotifier"},{"location":"error-handling/#basereactivestate","text":"The multiplatform ViewModel base class BaseReactiveState already provides an eventNotifier and a launch function that catches exceptions: class MyViewModel ( scope : CoroutineScope ) : BaseReactiveState < ErrorEvents > ( scope ) { init { launch { // ...code block... } } } This will automatically catch exceptions and trigger eventNotifier { onError(throwable) } . See Multiplatform ViewModels for more details.","title":"BaseReactiveState"},{"location":"event-handling/","text":"Event handling \u00b6 Events \u00b6 Events are modeled as simple interfaces where each event is a method: // The ErrorEvents interface is already part of this library interface ErrorEvents { // The onError event which contains the original exception fun onError ( error : Throwable ) } // Now a custom event type interface FooEvents { // the onFoo event which contains a \"name\" argument fun onFoo ( name : String ) // the onOtherFoo event fun onOtherFoo () } // You can combine multiple events easily via multiple inheritance interface CombinedEvents : FooEvents , ErrorEvents // And of course you can also add more events interface CombinedAndCustomEvents : FooEvents , ErrorEvents { fun onCustomEvent () } The last two examples show why events should be modeled as normal interfaces instead of sealed classes/interfaces. With normal interfaces you can combine multiple event types very easily (even events defined outside of the current module). In the next section we\u2019ll take a look at how those events can be triggered. Also see Error handling for details on our ErrorEvents interface which is used in several places in this library. EventNotifier \u00b6 The EventNotifier class is an event queue on which you can emit events and some other part of your code can collect the events. The EventNotifier is actually a Channel wrapped in a Flow interface. Events are buffered until someone collects them. This is important because you never want to lose events. In contrast, a SharedFlow is lossy - which is often not what you want. Example how to emit events: // This EventNotifier can emit any events contained in CombinedEvents val eventNotifier = EventNotifier < CombinedEvents > () fun doSomething () { // Explicit version eventNotifier . tryEmit { onFoo ( \"Slim Shady\" ) } // Or the recommended, shorter version eventNotifier { onFoo ( \"Slim Shady\" ) } eventNotifier { onOtherFoo ( e ) } try { // ... } catch ( e : Throwable ) { eventNotifier { onError ( e ) } } } Example how you\u2019d collect events: // The event listener has to implement the respective events interface(s) class MyEventListener ( scope : CoroutineScope ) : CombinedEvents { init { scope . launch { eventNotifier . handleEvents ( this @MyEventListener ) } } override fun onFoo ( name : String ) { // The onFoo event got triggered. } override fun onError ( error : Throwable ) { // The onError event got triggered. If MyEventListener is some UI screen // you'd probably show an error dialog here. } // ... } Note: The multiplatform ViewModel BaseReactiveState already provides a built-in EventNotifier .","title":"Event handling"},{"location":"event-handling/#event-handling","text":"","title":"Event handling"},{"location":"event-handling/#events","text":"Events are modeled as simple interfaces where each event is a method: // The ErrorEvents interface is already part of this library interface ErrorEvents { // The onError event which contains the original exception fun onError ( error : Throwable ) } // Now a custom event type interface FooEvents { // the onFoo event which contains a \"name\" argument fun onFoo ( name : String ) // the onOtherFoo event fun onOtherFoo () } // You can combine multiple events easily via multiple inheritance interface CombinedEvents : FooEvents , ErrorEvents // And of course you can also add more events interface CombinedAndCustomEvents : FooEvents , ErrorEvents { fun onCustomEvent () } The last two examples show why events should be modeled as normal interfaces instead of sealed classes/interfaces. With normal interfaces you can combine multiple event types very easily (even events defined outside of the current module). In the next section we\u2019ll take a look at how those events can be triggered. Also see Error handling for details on our ErrorEvents interface which is used in several places in this library.","title":"Events"},{"location":"event-handling/#eventnotifier","text":"The EventNotifier class is an event queue on which you can emit events and some other part of your code can collect the events. The EventNotifier is actually a Channel wrapped in a Flow interface. Events are buffered until someone collects them. This is important because you never want to lose events. In contrast, a SharedFlow is lossy - which is often not what you want. Example how to emit events: // This EventNotifier can emit any events contained in CombinedEvents val eventNotifier = EventNotifier < CombinedEvents > () fun doSomething () { // Explicit version eventNotifier . tryEmit { onFoo ( \"Slim Shady\" ) } // Or the recommended, shorter version eventNotifier { onFoo ( \"Slim Shady\" ) } eventNotifier { onOtherFoo ( e ) } try { // ... } catch ( e : Throwable ) { eventNotifier { onError ( e ) } } } Example how you\u2019d collect events: // The event listener has to implement the respective events interface(s) class MyEventListener ( scope : CoroutineScope ) : CombinedEvents { init { scope . launch { eventNotifier . handleEvents ( this @MyEventListener ) } } override fun onFoo ( name : String ) { // The onFoo event got triggered. } override fun onError ( error : Throwable ) { // The onError event got triggered. If MyEventListener is some UI screen // you'd probably show an error dialog here. } // ... } Note: The multiplatform ViewModel BaseReactiveState already provides a built-in EventNotifier .","title":"EventNotifier"},{"location":"example-guess-the-number/","text":"Example: Guess the number \u00b6 Let\u2019s pretend we play the game \u201cguess the correct number\u201d where we can increment a number and submit it to the backend which then tells us whether we guessed correctly. The following is a short example based on a subset of the principles: a multiplatform ViewModel via BaseReactiveState (you can alternatively use the ReactiveState interface) event handling via BaseReactiveState.eventNotifier automatic error catching via BaseReactiveState.launch lifecycle aware Android UI via autoRun and by reactiveState (which observes BaseReactiveState.eventNotifier ) state restoration via StateFlowStore The most important missing bits: reactive StateFlow s via derived unit tests Note: You can alternatively use an Android ViewModel and/or combine only the features you prefer to use. Here\u2019s the sample code with a MainViewModel which triggers MainEvents that are handled by a MainScreen : // ErrorEvents provides just one core event: onError(error: Throwable) interface MainEvents : ErrorEvents { fun onCorrectNumberGuessed ( message : String ) } class MainViewModel ( scope : CoroutineScope , store : StateFlowStore , ) : BaseReactiveState < MainEvents > ( scope ) { // On state restoration, getData() will prefill the StateFlow with // the previous value. val lastMessage : StateFlow < String? > by store . getData ( null ) // That's the currently guessed number val number = MutableStateFlow ( 0 ) fun increment () { number . value += 1 } fun checkNumber () { // In contrast to scope.launch, the BaseReactiveState.launch function // automatically catches exceptions and triggers ErrorEvents.onError(throwable) // using an event queue accessible via BaseReactiveState.eventNotifier. launch { val successMessage : String? = backend . submitNumber ( number . value ) // Persist the last message for state restoration lastMessage . value = successMessage if ( successMessage != null ) { // Yay, we have guessed correctly! We should show a \"success\" dialog. // Since the dialog must be shown exactly once (even on UI recreation // or state restoration), we communicate the result via an event. // The code block passed to eventNotifier will be executed on the // MainScreen/Fragment in the >= STARTED state (it's lifecycle aware). eventNotifier { onCorrectNumberGuessed ( successMessage ) } } } } } // Now some Android-specific code for the main screen (hopefully with Jetpack Compose // the screen code will also become multiplatform someday) // The Fragment has to implement its ViewModel's events interface (MainEvents). class MainScreen : Fragment (), MainEvents { // Attaches a multiplatform ViewModel (a ReactiveState instance) to the fragment. // Within the `by reactiveState` block you have access to scope and stateFlowStore // which are taken from an internally created Android ViewModel that hosts the // ReactiveState instance. // The stateFlowStore is backed by a Android's SavedStateHandle (the official way to // deal with saved instance state at the ViewModel layer). // Finally, `by beactiveState` automatically processes MainViewModel.eventNotifier // within the >= STARTED state, as promised in the comment above. private val viewModel by reactiveState { MainViewModel ( scope , stateFlowStore ) } // Let's use Android view bindings private lateinit var binding : MainViewBinding override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // Let's imagine we have a button to increment the current number binding . incrementButton . setOnClickListener { viewModel . increment () } // And another button to check if the current number is correct binding . checkNumberButton . setOnClickListener { viewModel . checkNumber () } // With autoRun you can keep the UI in sync with one or more StateFlows. // The get() call retrieves the StateFlow.value and tells autoRun to re-execute // the code block whenever the accessed StateFlow is changed. // Here we want the info text to always show the current number. autoRun { binding . infoTextView . text = \"Your current guess: ${ get ( viewModel . number ) } \" } // Once we've found the correct number we want to disable the // \"increment\" and \"check number\" buttons because the game is over. // Also, if we're currently doing a request we want to disable the buttons, too. autoRun { // Here we're watching multiple StateFlows at the same time. // BaseReactiveState.loading is a StateFlow<Int> tracking the number of // currently running coroutines that were started via BaseReactiveState.launch. // This is just the simplest possible example. // Instead of using `loading` you can also distinguish between different // loading states if you want. val buttonsEnabled = get ( viewModel . lastMessage ) == null && get ( viewModel . loading ) == 0 binding . incrementButton . isEnabled = buttonsEnabled binding . checkNumberButton . isEnabled = buttonsEnabled } // You'd usually also observe viewModel.loading (or other loading states) to // show a loading indicator, but let's keep this example small... } override fun onCorrectNumberGuessed ( message : String ) { // Show a nice dialog, congratulating the user } override fun onError ( error : Throwable ) { // This event is triggered if any exception is uncaught in the ViewModel. // Usually you'd show an error dialog here. } } All of this code is lifecycle aware, only executing in the >= STARTED state. You don\u2019t need to plaster all your code with copy-pasted try-catch logic. Most of the time you can deal with errors in onError() .","title":"Example: Guess the number"},{"location":"example-guess-the-number/#example-guess-the-number","text":"Let\u2019s pretend we play the game \u201cguess the correct number\u201d where we can increment a number and submit it to the backend which then tells us whether we guessed correctly. The following is a short example based on a subset of the principles: a multiplatform ViewModel via BaseReactiveState (you can alternatively use the ReactiveState interface) event handling via BaseReactiveState.eventNotifier automatic error catching via BaseReactiveState.launch lifecycle aware Android UI via autoRun and by reactiveState (which observes BaseReactiveState.eventNotifier ) state restoration via StateFlowStore The most important missing bits: reactive StateFlow s via derived unit tests Note: You can alternatively use an Android ViewModel and/or combine only the features you prefer to use. Here\u2019s the sample code with a MainViewModel which triggers MainEvents that are handled by a MainScreen : // ErrorEvents provides just one core event: onError(error: Throwable) interface MainEvents : ErrorEvents { fun onCorrectNumberGuessed ( message : String ) } class MainViewModel ( scope : CoroutineScope , store : StateFlowStore , ) : BaseReactiveState < MainEvents > ( scope ) { // On state restoration, getData() will prefill the StateFlow with // the previous value. val lastMessage : StateFlow < String? > by store . getData ( null ) // That's the currently guessed number val number = MutableStateFlow ( 0 ) fun increment () { number . value += 1 } fun checkNumber () { // In contrast to scope.launch, the BaseReactiveState.launch function // automatically catches exceptions and triggers ErrorEvents.onError(throwable) // using an event queue accessible via BaseReactiveState.eventNotifier. launch { val successMessage : String? = backend . submitNumber ( number . value ) // Persist the last message for state restoration lastMessage . value = successMessage if ( successMessage != null ) { // Yay, we have guessed correctly! We should show a \"success\" dialog. // Since the dialog must be shown exactly once (even on UI recreation // or state restoration), we communicate the result via an event. // The code block passed to eventNotifier will be executed on the // MainScreen/Fragment in the >= STARTED state (it's lifecycle aware). eventNotifier { onCorrectNumberGuessed ( successMessage ) } } } } } // Now some Android-specific code for the main screen (hopefully with Jetpack Compose // the screen code will also become multiplatform someday) // The Fragment has to implement its ViewModel's events interface (MainEvents). class MainScreen : Fragment (), MainEvents { // Attaches a multiplatform ViewModel (a ReactiveState instance) to the fragment. // Within the `by reactiveState` block you have access to scope and stateFlowStore // which are taken from an internally created Android ViewModel that hosts the // ReactiveState instance. // The stateFlowStore is backed by a Android's SavedStateHandle (the official way to // deal with saved instance state at the ViewModel layer). // Finally, `by beactiveState` automatically processes MainViewModel.eventNotifier // within the >= STARTED state, as promised in the comment above. private val viewModel by reactiveState { MainViewModel ( scope , stateFlowStore ) } // Let's use Android view bindings private lateinit var binding : MainViewBinding override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // Let's imagine we have a button to increment the current number binding . incrementButton . setOnClickListener { viewModel . increment () } // And another button to check if the current number is correct binding . checkNumberButton . setOnClickListener { viewModel . checkNumber () } // With autoRun you can keep the UI in sync with one or more StateFlows. // The get() call retrieves the StateFlow.value and tells autoRun to re-execute // the code block whenever the accessed StateFlow is changed. // Here we want the info text to always show the current number. autoRun { binding . infoTextView . text = \"Your current guess: ${ get ( viewModel . number ) } \" } // Once we've found the correct number we want to disable the // \"increment\" and \"check number\" buttons because the game is over. // Also, if we're currently doing a request we want to disable the buttons, too. autoRun { // Here we're watching multiple StateFlows at the same time. // BaseReactiveState.loading is a StateFlow<Int> tracking the number of // currently running coroutines that were started via BaseReactiveState.launch. // This is just the simplest possible example. // Instead of using `loading` you can also distinguish between different // loading states if you want. val buttonsEnabled = get ( viewModel . lastMessage ) == null && get ( viewModel . loading ) == 0 binding . incrementButton . isEnabled = buttonsEnabled binding . checkNumberButton . isEnabled = buttonsEnabled } // You'd usually also observe viewModel.loading (or other loading states) to // show a loading indicator, but let's keep this example small... } override fun onCorrectNumberGuessed ( message : String ) { // Show a nice dialog, congratulating the user } override fun onError ( error : Throwable ) { // This event is triggered if any exception is uncaught in the ViewModel. // Usually you'd show an error dialog here. } } All of this code is lifecycle aware, only executing in the >= STARTED state. You don\u2019t need to plaster all your code with copy-pasted try-catch logic. Most of the time you can deal with errors in onError() .","title":"Example: Guess the number"},{"location":"lifecycle-handling/","text":"Correct lifecycle handling \u00b6 interface MainEvents : ErrorEvents { fun showMessage ( message : String ) } // You can create a multiplatform ViewModel by deriving from // BaseReactiveState instead. More details below. class MainViewModel : ViewModel () { // This queue can be used to send events to the MainEvents in the STARTED // lifecycle state. Instead of boilerplaty event sealed classes we use a // simple MainEvents interface with methods. val eventNotifier = EventNotifier < MainEvents > () fun someAction () { viewModelScope . launch { val result = api . requestSomeAction () // Switch back to MainFragment (the latest visible instance). eventNotifier { // If the screen got rotated in the meantime, `this` would point // to the new MainFragment instance instead of the destroyed one // that did the initial `someAction` call above. showMessage ( result . someMessage ) } } } } class MainFragment : Fragment (), MainEvents { private val viewModel : MainViewModel by viewModels () init { // Execute the MainViewModel's events in the >=STARTED state to prevent crashes lifecycleScope . launchWhenStarted { viewModel . eventNotifier . collect { it () } } } // ... override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup?, savedInstanceState : Bundle? ): View { // ... // val button = ... button . setOnClickListener { viewModel . someAction () } // ... } fun showMessage ( message : String ) { // ... } } On Android, managing operations independently of the UI lifecycle (e.g. button click -> request -> UI rotated -> response -> UI update/navigation) is made unnecessarily difficult because Android can destroy your UI in the middle of an operation. To work around this, you\u2019ll usually launch a coroutine in ViewModel.viewModelScope and/or use a Channel to communicate between the ViewModel and the UI. In order to simplify this pattern, ReactiveState provides EventNotifier and the lower-level MutableFlow (which has buffered, exactly-once consumption semantics like a Channel ). Automatic cleanups based on lifecycle state \u00b6 Especially on Android it\u2019s very easy to shoot yourself in the foot and e.g. have a closure that keeps a reference to a destroyed Fragment or mistakenly execute code on a destroyed UI. ReactiveState provides a Disposable interface and most objects auto-dispose/terminate when a CoroutineScope or Android Lifecycle ends. You can also use disposable.disposeOnCompletionOf to auto-dispose your disposables. For more complex use-cases you can use DisposableGroup to combine (add/remove) multiple disposables into a single Disposable object. With extension functions like LifecycleOwner.onResume or LifecycleOwner.onStopOnce you can easily add long-running or one-time observers to a Lifecycle . These are the building blocks for your own lifecycle-aware components which can automatically clean up after themselves like LifecycleOwner.autoRun does. Finally, with validUntil() you can define properties that only exist during a certain lifecycle subset and are dereference their value outside of that lifecycle subset. This can get rid of the ugly boilerplate when working with view bindings, for example.","title":"Lifecycle handling"},{"location":"lifecycle-handling/#correct-lifecycle-handling","text":"interface MainEvents : ErrorEvents { fun showMessage ( message : String ) } // You can create a multiplatform ViewModel by deriving from // BaseReactiveState instead. More details below. class MainViewModel : ViewModel () { // This queue can be used to send events to the MainEvents in the STARTED // lifecycle state. Instead of boilerplaty event sealed classes we use a // simple MainEvents interface with methods. val eventNotifier = EventNotifier < MainEvents > () fun someAction () { viewModelScope . launch { val result = api . requestSomeAction () // Switch back to MainFragment (the latest visible instance). eventNotifier { // If the screen got rotated in the meantime, `this` would point // to the new MainFragment instance instead of the destroyed one // that did the initial `someAction` call above. showMessage ( result . someMessage ) } } } } class MainFragment : Fragment (), MainEvents { private val viewModel : MainViewModel by viewModels () init { // Execute the MainViewModel's events in the >=STARTED state to prevent crashes lifecycleScope . launchWhenStarted { viewModel . eventNotifier . collect { it () } } } // ... override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup?, savedInstanceState : Bundle? ): View { // ... // val button = ... button . setOnClickListener { viewModel . someAction () } // ... } fun showMessage ( message : String ) { // ... } } On Android, managing operations independently of the UI lifecycle (e.g. button click -> request -> UI rotated -> response -> UI update/navigation) is made unnecessarily difficult because Android can destroy your UI in the middle of an operation. To work around this, you\u2019ll usually launch a coroutine in ViewModel.viewModelScope and/or use a Channel to communicate between the ViewModel and the UI. In order to simplify this pattern, ReactiveState provides EventNotifier and the lower-level MutableFlow (which has buffered, exactly-once consumption semantics like a Channel ).","title":"Correct lifecycle handling"},{"location":"lifecycle-handling/#automatic-cleanups-based-on-lifecycle-state","text":"Especially on Android it\u2019s very easy to shoot yourself in the foot and e.g. have a closure that keeps a reference to a destroyed Fragment or mistakenly execute code on a destroyed UI. ReactiveState provides a Disposable interface and most objects auto-dispose/terminate when a CoroutineScope or Android Lifecycle ends. You can also use disposable.disposeOnCompletionOf to auto-dispose your disposables. For more complex use-cases you can use DisposableGroup to combine (add/remove) multiple disposables into a single Disposable object. With extension functions like LifecycleOwner.onResume or LifecycleOwner.onStopOnce you can easily add long-running or one-time observers to a Lifecycle . These are the building blocks for your own lifecycle-aware components which can automatically clean up after themselves like LifecycleOwner.autoRun does. Finally, with validUntil() you can define properties that only exist during a certain lifecycle subset and are dereference their value outside of that lifecycle subset. This can get rid of the ugly boilerplate when working with view bindings, for example.","title":"Automatic cleanups based on lifecycle state"},{"location":"multiplatform-viewmodels/","text":"Multiplatform ViewModels \u00b6 This library allows creating multiplatform ViewModels (inherited from BaseReactiveState ) and also provides a by reactiveState helper for attaching it to Android\u2019s Activity or Fragment with proper lifecycle handling. // This is a multiplatform \"ViewModel\". It doesn't inherit from Android's ViewModel // and doesn't depend on any Android code. // It can persist saved instance state via StateFlowStore. On iOS you could pass // e.g. an InMemoryStateFlowStore. // The base class for such ViewModels (and other \"living\" stateful objects) // is BaseReactiveState. You can alternatively use the ReactiveState interface // e.g. together with delegation. class MultiPlatformViewModel ( scope : CoroutineScope , // The StateFlowStore allows for state restoration (like onSaveInstanceState). // See next section for details. private val store : StateFlowStore , // For dependency injection private val dependency : SomeDependency , ) : BaseReactiveState < MyEvents > ( scope ) { val data = MutableStateFlow ( \"hello\" ) fun doSomething () { // In contrast to scope.launch, the BaseReactiveState.launch function // automatically catches exceptions and forwards them to eventNotifier // via ErrorEvents.onError(throwable). launch { val result = callSomeSuspendFun () data . value = result // BaseReactiveState comes with a built-in eventNotifier eventNotifier { ... } } } } interface MyEvents : ErrorEvents { fun onResultReceived () } // Alternatively, this is an example in case you want to use Android-native ViewModels. // This ViewModel can persist state with SavedStateHandle (no more onSaveInstanceState() boilerplate) class StateViewModel ( val handle : SavedStateHandle , dependency : SomeDependency ) : ViewModel () { // ... } // Example integration with Android class MainFragment : Fragment () { // Attaches a multiplatform ViewModel (ReactiveState) to the fragment. // Within the \"by reactiveState\" block you have access to scope and stateFlowStore which are taken from an // internally created Android ViewModel that hosts the ReactiveState instance. private val multiPlatformViewModel by reactiveState { MultiPlatformViewModel ( scope , stateFlowStore , SomeDependency ()) } // Alternatively, for Android ViewModels there's stateViewModel and buildViewModel private val viewModel by stateViewModel { handle -> StateViewModel ( handle , SomeDependency ()) } // With buildOnViewModel you can create an arbitrary object that lives on an internally created wrapper ViewModel. // The \"by reactiveState\" helper is using this internally. private val someObjectOnAViewModel by buildOnViewModel { SomeObject () } } With buildOnViewModel you can create your fully custom ViewModel if prefer. However, BaseReactiveState comes with batteries included: event handling: Send one-time events to the UI via eventNotifier . error handling: launch catches all errors and forwards them to eventNotifier via ErrorEvents.onError(throwable) . lifecycle handling: With by reactiveState the eventNotifier is automatically observed in the >= STARTED state. loading indicators: launch automatically maintains a loading StateFlow , so you can show a loading indicator in the UI while the coroutine is running. This can use either the default loading or any custom MutableValueFlow<Int> , so you can distinguish different loading states, each having its own loading indicator in the UI. For Android, ReactiveState\u2019s by reactiveState , by buildViewModel , by stateViewModel , by buildOnViewModel , and similar extension functions allow creating a ViewModel by directly instantiating it. This results in more natural code and allows passing arguments to the ViewModel . Internally, these helper functions are simple wrappers around viewModels , ViewModelProvider.Factory and AbstractSavedStateViewModelFactory . They just reduce the amount of boilerplate for common use-cases. Launching coroutines \u00b6 To give you a deeper understanding what happens when you run: launch { // ...code block... } That piece of code is similar to writing this: scope . launch { loading . atomicIncrement () // however that works try { // ...code block... } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { eventNotifier . invoke { onError ( e ) } // explicitly writing invoke for clarity only } finally { loading . atomicDecrement () // however that works } } Customizing by reactiveState \u00b6 You can implement the OnReactiveStateAttached interface on your Fragment / Activity in order to customize the attachment procedure: class MyFragment : Fragment (), OnReactiveStateAttached , ErrorEvents { val viewModel by reactiveState { ... } override fun onReactiveStateAttached ( reactiveState : ReactiveState < out ErrorEvents > ) { autoRun { setLoading ( get ( reactiveState . loading ) > 0 ) } } fun setLoading ( isLoading : Boolean ) { // ... } } Alternatively, if you want to support multiple ViewModels and merge all their loadings states into one: class MyFragment : Fragment (), OnReactiveStateAttached , ErrorEvents { // We'll merge the loading states of all ReactiveState instances into this one val loading = MutableValueFlow ( 0 ) val viewModel by reactiveState { ... } val viewModel2 by reactiveState { ... } val viewModel3 by reactiveState { ... } override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) autoRun { setLoading ( get ( loading ) > 0 ) } } fun setLoading ( isLoading : Boolean ) { // ... } override fun onReactiveStateAttached ( reactiveState : ReactiveState < out ErrorEvents > ) { lifecycleScope . launch { // Sum all loading states loading . incrementFrom ( reactiveState . loading ) } } }","title":"Multiplatform ViewModels"},{"location":"multiplatform-viewmodels/#multiplatform-viewmodels","text":"This library allows creating multiplatform ViewModels (inherited from BaseReactiveState ) and also provides a by reactiveState helper for attaching it to Android\u2019s Activity or Fragment with proper lifecycle handling. // This is a multiplatform \"ViewModel\". It doesn't inherit from Android's ViewModel // and doesn't depend on any Android code. // It can persist saved instance state via StateFlowStore. On iOS you could pass // e.g. an InMemoryStateFlowStore. // The base class for such ViewModels (and other \"living\" stateful objects) // is BaseReactiveState. You can alternatively use the ReactiveState interface // e.g. together with delegation. class MultiPlatformViewModel ( scope : CoroutineScope , // The StateFlowStore allows for state restoration (like onSaveInstanceState). // See next section for details. private val store : StateFlowStore , // For dependency injection private val dependency : SomeDependency , ) : BaseReactiveState < MyEvents > ( scope ) { val data = MutableStateFlow ( \"hello\" ) fun doSomething () { // In contrast to scope.launch, the BaseReactiveState.launch function // automatically catches exceptions and forwards them to eventNotifier // via ErrorEvents.onError(throwable). launch { val result = callSomeSuspendFun () data . value = result // BaseReactiveState comes with a built-in eventNotifier eventNotifier { ... } } } } interface MyEvents : ErrorEvents { fun onResultReceived () } // Alternatively, this is an example in case you want to use Android-native ViewModels. // This ViewModel can persist state with SavedStateHandle (no more onSaveInstanceState() boilerplate) class StateViewModel ( val handle : SavedStateHandle , dependency : SomeDependency ) : ViewModel () { // ... } // Example integration with Android class MainFragment : Fragment () { // Attaches a multiplatform ViewModel (ReactiveState) to the fragment. // Within the \"by reactiveState\" block you have access to scope and stateFlowStore which are taken from an // internally created Android ViewModel that hosts the ReactiveState instance. private val multiPlatformViewModel by reactiveState { MultiPlatformViewModel ( scope , stateFlowStore , SomeDependency ()) } // Alternatively, for Android ViewModels there's stateViewModel and buildViewModel private val viewModel by stateViewModel { handle -> StateViewModel ( handle , SomeDependency ()) } // With buildOnViewModel you can create an arbitrary object that lives on an internally created wrapper ViewModel. // The \"by reactiveState\" helper is using this internally. private val someObjectOnAViewModel by buildOnViewModel { SomeObject () } } With buildOnViewModel you can create your fully custom ViewModel if prefer. However, BaseReactiveState comes with batteries included: event handling: Send one-time events to the UI via eventNotifier . error handling: launch catches all errors and forwards them to eventNotifier via ErrorEvents.onError(throwable) . lifecycle handling: With by reactiveState the eventNotifier is automatically observed in the >= STARTED state. loading indicators: launch automatically maintains a loading StateFlow , so you can show a loading indicator in the UI while the coroutine is running. This can use either the default loading or any custom MutableValueFlow<Int> , so you can distinguish different loading states, each having its own loading indicator in the UI. For Android, ReactiveState\u2019s by reactiveState , by buildViewModel , by stateViewModel , by buildOnViewModel , and similar extension functions allow creating a ViewModel by directly instantiating it. This results in more natural code and allows passing arguments to the ViewModel . Internally, these helper functions are simple wrappers around viewModels , ViewModelProvider.Factory and AbstractSavedStateViewModelFactory . They just reduce the amount of boilerplate for common use-cases.","title":"Multiplatform ViewModels"},{"location":"multiplatform-viewmodels/#launching-coroutines","text":"To give you a deeper understanding what happens when you run: launch { // ...code block... } That piece of code is similar to writing this: scope . launch { loading . atomicIncrement () // however that works try { // ...code block... } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { eventNotifier . invoke { onError ( e ) } // explicitly writing invoke for clarity only } finally { loading . atomicDecrement () // however that works } }","title":"Launching coroutines"},{"location":"multiplatform-viewmodels/#customizing-by-reactivestate","text":"You can implement the OnReactiveStateAttached interface on your Fragment / Activity in order to customize the attachment procedure: class MyFragment : Fragment (), OnReactiveStateAttached , ErrorEvents { val viewModel by reactiveState { ... } override fun onReactiveStateAttached ( reactiveState : ReactiveState < out ErrorEvents > ) { autoRun { setLoading ( get ( reactiveState . loading ) > 0 ) } } fun setLoading ( isLoading : Boolean ) { // ... } } Alternatively, if you want to support multiple ViewModels and merge all their loadings states into one: class MyFragment : Fragment (), OnReactiveStateAttached , ErrorEvents { // We'll merge the loading states of all ReactiveState instances into this one val loading = MutableValueFlow ( 0 ) val viewModel by reactiveState { ... } val viewModel2 by reactiveState { ... } val viewModel3 by reactiveState { ... } override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) autoRun { setLoading ( get ( loading ) > 0 ) } } fun setLoading ( isLoading : Boolean ) { // ... } override fun onReactiveStateAttached ( reactiveState : ReactiveState < out ErrorEvents > ) { lifecycleScope . launch { // Sum all loading states loading . incrementFrom ( reactiveState . loading ) } } }","title":"Customizing by reactiveState"},{"location":"mutablevalueflow/","text":"MutableValueFlow \u00b6 MutableValueFlow implements the same API as MutableStateFlow , but also provides some extras: The replaceLocked method allows safely replacing the current value under concurrent updates: // SubValue1 and SubValue2 are other data class data class SomeValue ( val subvalue1 : SubValue1 , val subvalue2 : SubValue2 , val isLoading : Boolean ) val valueFlow = MutableValueFlow ( SomeValue ( isLoading = false , /* ... */ )) valueFlow . replaceLocked { copy ( isLoading = true ) } // now valueFlow.value.isLoading is true Note: ReactiveState also provides an extension function, replace , which is defined on MutableStateFlow (and MutableValueFlow ) which does the same thing as replaceLocked , but without the concurrency safety. Additionally, MutableValueFlow has an update method for working with mutable values: // Now with var instead of val data class SomeValue ( var subvalue1 : SubValue1 , var subvalue2 : SubValue2 , var isLoading : Boolean ) // MutableValueFlow valueFlow . update { it . subvalue1 . deepsubvalue . somevalue += 3 it . subvalue2 . state = SomeState . IN_PROGRESS it . isLoading = true } // versus MutableStateFlow stateFlow . value = flow . value . let { it . copy ( subvalue1 = it . subvalue1 . copy ( deepsubvalue = it . subvalue1 . deepsubvalue . copy ( somevalue = it . subvalue1 . deepsubvalue . somevalue + 3 ) ), subvalue2 = it . subvalue2 . copy ( state = SomeState . IN_PROGRESS ), isLoading = true , ) } If you work with immutable data classes then you might know this problem. You can make immutable data less painful with functional lenses (e.g. arrow Optics DSL and arrow Lens ), but that can still result in complicated and inefficient code. On the other hand, mutable data does allow to shoot yourself in the foot. So whether you want to use MutableValueFlow is a question of your architecture and code structure and the specific circumstances. Usually, reactive code consciously puts data into observables ( StateFlow s) in order to allow for reactivity. This results in a code structure where these StateFlow s are the primary hosts of each piece of data and the mutations are limited around each StateFlow or even around the observable database as the single source of truth. Under these circumstances it can be quite safe to work with mutable data and MutableValueFlow makes such use-cases simpler than MutableStateFlow . Sometimes you even have a mutable third-party object (e.g. AtomicInteger ) that you have to work with and StateFlow is impossible to use in those cases.","title":"MutableValueFlow"},{"location":"mutablevalueflow/#mutablevalueflow","text":"MutableValueFlow implements the same API as MutableStateFlow , but also provides some extras: The replaceLocked method allows safely replacing the current value under concurrent updates: // SubValue1 and SubValue2 are other data class data class SomeValue ( val subvalue1 : SubValue1 , val subvalue2 : SubValue2 , val isLoading : Boolean ) val valueFlow = MutableValueFlow ( SomeValue ( isLoading = false , /* ... */ )) valueFlow . replaceLocked { copy ( isLoading = true ) } // now valueFlow.value.isLoading is true Note: ReactiveState also provides an extension function, replace , which is defined on MutableStateFlow (and MutableValueFlow ) which does the same thing as replaceLocked , but without the concurrency safety. Additionally, MutableValueFlow has an update method for working with mutable values: // Now with var instead of val data class SomeValue ( var subvalue1 : SubValue1 , var subvalue2 : SubValue2 , var isLoading : Boolean ) // MutableValueFlow valueFlow . update { it . subvalue1 . deepsubvalue . somevalue += 3 it . subvalue2 . state = SomeState . IN_PROGRESS it . isLoading = true } // versus MutableStateFlow stateFlow . value = flow . value . let { it . copy ( subvalue1 = it . subvalue1 . copy ( deepsubvalue = it . subvalue1 . deepsubvalue . copy ( somevalue = it . subvalue1 . deepsubvalue . somevalue + 3 ) ), subvalue2 = it . subvalue2 . copy ( state = SomeState . IN_PROGRESS ), isLoading = true , ) } If you work with immutable data classes then you might know this problem. You can make immutable data less painful with functional lenses (e.g. arrow Optics DSL and arrow Lens ), but that can still result in complicated and inefficient code. On the other hand, mutable data does allow to shoot yourself in the foot. So whether you want to use MutableValueFlow is a question of your architecture and code structure and the specific circumstances. Usually, reactive code consciously puts data into observables ( StateFlow s) in order to allow for reactivity. This results in a code structure where these StateFlow s are the primary hosts of each piece of data and the mutations are limited around each StateFlow or even around the observable database as the single source of truth. Under these circumstances it can be quite safe to work with mutable data and MutableValueFlow makes such use-cases simpler than MutableStateFlow . Sometimes you even have a mutable third-party object (e.g. AtomicInteger ) that you have to work with and StateFlow is impossible to use in those cases.","title":"MutableValueFlow"},{"location":"reactive-programming/","text":"Reactive programming \u00b6 val number = MutableStateFlow ( 0 ) // For complex apps you often need reactive StateFlows. That's what derived() is for. // This StateFlow is automatically recomputed whenever number's value is changed val doubledNumber : StateFlow < Int > = derived { 2 * get ( number ) } // Here we only compute the value while someone is subscribed to changes (autoRun, // derived or collect). This can be important for expensive computations/operations. val onDemandDoubledNumber = derived ( initial = 0 , started = WhileSubscribed ()) { // Note: you could even call suspension functions from within this block // to e.g. fetch something from the backend. 2 * get ( number ) } With autoRun (available on LifecycleOwner , ViewModel , CoroutineScope , etc.) you can observe and re-execute a function whenever any of the StateFlow or LiveData instances accessed by that function are modified. On Android you can use this to keeping the UI in sync with your ViewModel. Of course, you can also keep non-UI state in sync. Depending on the context in which autoRun is executed, this observer is automatically tied to a CoroutineScope (e.g. the ViewModel \u2018s viewModelScope ) or in case of a Fragment / Activity to the onStart() / onStop() lifecycle in order to prevent accidental crashes and unnecessary resource consumption. With derived you can construct new StateFlow s based on the autoRun principle. You can control when the calculation should run by passing Eagerly , Lazily or WhileSubscribed() , for example. Especially WhileSubscribed() is important for expensive computations. Note that autoRun can be extended to support observables other than StateFlow , LiveData and WhileUsed . The simplicity advantage of autoRun / derived requires using StateFlow instead of Flow to avoid writing chains of combine , map , flatMapLatest , conflate , etc. Luckily, if you only have a Flow , you can use Flow.stateIn() to convert it to a StateFlow .","title":"Reactive programming"},{"location":"reactive-programming/#reactive-programming","text":"val number = MutableStateFlow ( 0 ) // For complex apps you often need reactive StateFlows. That's what derived() is for. // This StateFlow is automatically recomputed whenever number's value is changed val doubledNumber : StateFlow < Int > = derived { 2 * get ( number ) } // Here we only compute the value while someone is subscribed to changes (autoRun, // derived or collect). This can be important for expensive computations/operations. val onDemandDoubledNumber = derived ( initial = 0 , started = WhileSubscribed ()) { // Note: you could even call suspension functions from within this block // to e.g. fetch something from the backend. 2 * get ( number ) } With autoRun (available on LifecycleOwner , ViewModel , CoroutineScope , etc.) you can observe and re-execute a function whenever any of the StateFlow or LiveData instances accessed by that function are modified. On Android you can use this to keeping the UI in sync with your ViewModel. Of course, you can also keep non-UI state in sync. Depending on the context in which autoRun is executed, this observer is automatically tied to a CoroutineScope (e.g. the ViewModel \u2018s viewModelScope ) or in case of a Fragment / Activity to the onStart() / onStop() lifecycle in order to prevent accidental crashes and unnecessary resource consumption. With derived you can construct new StateFlow s based on the autoRun principle. You can control when the calculation should run by passing Eagerly , Lazily or WhileSubscribed() , for example. Especially WhileSubscribed() is important for expensive computations. Note that autoRun can be extended to support observables other than StateFlow , LiveData and WhileUsed . The simplicity advantage of autoRun / derived requires using StateFlow instead of Flow to avoid writing chains of combine , map , flatMapLatest , conflate , etc. Luckily, if you only have a Flow , you can use Flow.stateIn() to convert it to a StateFlow .","title":"Reactive programming"},{"location":"state-restoration/","text":"State restoration \u00b6 // Multiplatform ViewModel class MainViewModel ( scope : CoroutineScope , store : StateFlowStore ) : BaseReactiveState < ErrorEvents > ( scope ) { val count : StateFlow < Int > = store . getData ( \"count\" , 0 ) } // Android ViewModel class MainViewModel ( store : StateFlowStore ) : ViewModel () { val count : StateFlow < Int > = store . getData ( \"count\" , 0 ) } A StateFlowStore provides a similar API to Android\u2019s SavedStateHandle , but based on StateFlow instead of LiveData . With InMemoryStateFlowStore you can do e.g. unit testing or abstract away platform differences in multiplatform projects. This is how you can create an Android ViewModel with a StateFlowStore : // Multiplatform ViewModel class MainFragment : Fragment () { private val viewModel by reactiveState { MainViewModel ( scope , stateFlowStore ) } // ... } // Android ViewModel class MainFragment : Fragment () { private val viewModel by stateFlowViewModel { MainViewModel ( stateFlowStore ) } // ... } Both by reactiveState and by stateFlowViewModel provide a stateFlowStore value within their lambda blocks.","title":"State restoration"},{"location":"state-restoration/#state-restoration","text":"// Multiplatform ViewModel class MainViewModel ( scope : CoroutineScope , store : StateFlowStore ) : BaseReactiveState < ErrorEvents > ( scope ) { val count : StateFlow < Int > = store . getData ( \"count\" , 0 ) } // Android ViewModel class MainViewModel ( store : StateFlowStore ) : ViewModel () { val count : StateFlow < Int > = store . getData ( \"count\" , 0 ) } A StateFlowStore provides a similar API to Android\u2019s SavedStateHandle , but based on StateFlow instead of LiveData . With InMemoryStateFlowStore you can do e.g. unit testing or abstract away platform differences in multiplatform projects. This is how you can create an Android ViewModel with a StateFlowStore : // Multiplatform ViewModel class MainFragment : Fragment () { private val viewModel by reactiveState { MainViewModel ( scope , stateFlowStore ) } // ... } // Android ViewModel class MainFragment : Fragment () { private val viewModel by stateFlowViewModel { MainViewModel ( stateFlowStore ) } // ... } Both by reactiveState and by stateFlowViewModel provide a stateFlowStore value within their lambda blocks.","title":"State restoration"},{"location":"unit-testing-coroutines/","text":"Unit tests with coroutines \u00b6 The CoroutineTest base class provides some often useful helpers for working with coroutines. class MyTest : CoroutineTest () { // This works because MainScope/Dispatchers.Main is automatically set up correctly by CoroutineTest val viewModel = MyViewModel () // Let's use a mock to test the events emitted by MyViewModel val events : MyEvents = mock () @Before fun setup () { // You can access the TestCoroutineScope directly to launch some background processing. // In this case, let's process MyViewModel's events. testCoroutineScope . launch { viewModel . eventNotifier . collect { events . it () } } } @Test fun `some test` () = runBlockingTest { viewModel . doSomething () advanceUntilIdle () verify ( events ). someEvent () } } This also sets up a global dispatchers variable which you can use in all of your code instead of passing a CoroutineDispatcher around as arguments: // Use this instead of Dispatchers.IO. In unit tests this will automatically use // the TestCoroutineDispatcher instead. Outside of unit tests it points to Dispatchers.IO. // You can also define your own overrides if you want. withContext ( dispatchers . io ) { // do some IO } If you can\u2019t derive from CoroutineTest directly (e.g. because you have some other base test class), you can alternatively use composition with the CoroutineTestRule : class MyTest { val rule = CoroutineTestRule () @Test fun `some test` () = rule . runBlockingTest { // ... } }","title":"Unit testing coroutines"},{"location":"unit-testing-coroutines/#unit-tests-with-coroutines","text":"The CoroutineTest base class provides some often useful helpers for working with coroutines. class MyTest : CoroutineTest () { // This works because MainScope/Dispatchers.Main is automatically set up correctly by CoroutineTest val viewModel = MyViewModel () // Let's use a mock to test the events emitted by MyViewModel val events : MyEvents = mock () @Before fun setup () { // You can access the TestCoroutineScope directly to launch some background processing. // In this case, let's process MyViewModel's events. testCoroutineScope . launch { viewModel . eventNotifier . collect { events . it () } } } @Test fun `some test` () = runBlockingTest { viewModel . doSomething () advanceUntilIdle () verify ( events ). someEvent () } } This also sets up a global dispatchers variable which you can use in all of your code instead of passing a CoroutineDispatcher around as arguments: // Use this instead of Dispatchers.IO. In unit tests this will automatically use // the TestCoroutineDispatcher instead. Outside of unit tests it points to Dispatchers.IO. // You can also define your own overrides if you want. withContext ( dispatchers . io ) { // do some IO } If you can\u2019t derive from CoroutineTest directly (e.g. because you have some other base test class), you can alternatively use composition with the CoroutineTestRule : class MyTest { val rule = CoroutineTestRule () @Test fun `some test` () = rule . runBlockingTest { // ... } }","title":"Unit tests with coroutines"},{"location":"reference/","text":"// reactivestate-test reactivestate-test \u00b6 Packages \u00b6 Name com.ensody.reactivestate.test","title":"Index"},{"location":"reference/#reactivestate-test","text":"","title":"reactivestate-test"},{"location":"reference/#packages","text":"Name com.ensody.reactivestate.test","title":"Packages"},{"location":"reference/reactivestate/com.ensody.reactivestate/","text":"// reactivestate / com.ensody.reactivestate Package com.ensody.reactivestate \u00b6 Types \u00b6 Name Summary AttachedDisposables Platforms: common interface AttachedDisposables : DisposableHandle A Disposable that can have additional Disposables attached to it, so they are automatically disposed together with this object. AutoRunCallback Platforms: common typealias AutoRunCallback < T > = Resolver .() -> T Observer callback used by autoRun and AutoRunner . AutoRunFlowTransformer Platforms: common typealias AutoRunFlowTransformer = suspend Flow Unit >.() -> Flow< Unit > Collector of the change events used by coAutoRun and CoAutoRunner . AutoRunner Platforms: common class AutoRunner < T >( launcher : CoroutineLauncher , onChange : AutoRunOnChangeCallback < T >?, flowTransformer : AutoRunFlowTransformer , observer : AutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. AutoRunnerObservable Platforms: common interface AutoRunnerObservable Base interface for observing a hard-coded AutoRunner instance. AutoRunOnChangeCallback Platforms: common typealias AutoRunOnChangeCallback < T > = ( AutoRunner < T >) -> Unit onChange callback used by autoRun and AutoRunner . BaseAutoRunner Platforms: common abstract class BaseAutoRunner : AttachedDisposables Just the minimum interface needed for Resolver . BaseReactiveState Platforms: common open class BaseReactiveState < E : ErrorEvents >( scope : CoroutineScope) : SimpleCoroutineLauncher , ReactiveState < E > Base class/delegate for ViewModels and other objects that can trigger one-time events/actions and handle errors. BaseSuspendMutableValueFlow Platforms: common @ ExperimentalReactiveStateApi () abstract class BaseSuspendMutableValueFlow < T > : ValueFlow < T > , SuspendMutableValueFlow < T > Base class for StateFlows that can be mutated only via suspend functions - in contrast to assigning the value . CoAutoRunCallback Platforms: common typealias CoAutoRunCallback < T > = suspend Resolver .() -> T Observer callback used by suspendable coAutoRun and CoAutoRunner . CoAutoRunner Platforms: common class CoAutoRunner < T >( launcher : CoroutineLauncher , onChange : CoAutoRunOnChangeCallback < T >?, flowTransformer : AutoRunFlowTransformer , dispatcher : CoroutineDispatcher, withLoading : MutableValueFlow < Int >?, observer : CoAutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. CoAutoRunOnChangeCallback Platforms: common typealias CoAutoRunOnChangeCallback < T > = suspend ( CoAutoRunner < T >) -> Unit onChange callback used by suspendable coAutoRun and CoAutoRunner . CoroutineDispatcherConfig Platforms: common interface CoroutineDispatcherConfig Interface for a common set of CoroutineDispatchers. CoroutineLauncher Platforms: common interface CoroutineLauncher Interface for launching coroutines with error handling and loading state tracking. DefaultCoroutineDispatcherConfig Platforms: common object DefaultCoroutineDispatcherConfig : CoroutineDispatcherConfig The default CoroutineDispatcherConfig , mapping to Dispatchers. Disposable Platforms: common typealias Disposable = DisposableHandle An object that can be disposed/deactivated/canceled by calling dispose(). This is an alias for DisposableHandle. DisposableGroup Platforms: common interface DisposableGroup : DisposableHandle A Disposable that can dispose multiple Disposable and Job instances at once. DisposableValue Platforms: common class DisposableValue < T >( value : T , disposer : () -> Unit ) : DisposableHandle A value that must be explicitly dispose d when it\u2019s not needed anymore. ErrorEvents Platforms: common interface ErrorEvents Events interface with a simple onError event (e.g. EventNotifier Platforms: common interface EventNotifier < T > : MutableFlow T .() -> Unit > This is used to send events to an observer. ExperimentalReactiveStateApi Platforms: common annotation class ExperimentalReactiveStateApi This feature is not stable yet and can introduce breaking API changes in minor releases. InMemoryStateFlowStore Platforms: common class InMemoryStateFlowStore : StateFlowStore A StateFlowStore that can be used for unit tests or non-Android parts of multiplatform projects. InternalBaseAutoRunner Platforms: common abstract class InternalBaseAutoRunner ( launcher : CoroutineLauncher , flowTransformer : AutoRunFlowTransformer ) : BaseAutoRunner JobDisposable Platforms: common class JobDisposable ( job : Job) : DisposableHandle A Disposable wrapping a Job. MutableFlow Platforms: common interface MutableFlow < T > : Flow< T > , FlowCollector< T > A Flow where you can emit/ tryEmit values into (backed by a Channel). MutableValueFlow Platforms: common interface MutableValueFlow < T > : ValueFlow < T > , MutableStateFlow< T > A version of MutableStateFlow that provides better support for mutable values via the update operation. NamespacedStateFlowStore Platforms: common class NamespacedStateFlowStore ( store : StateFlowStore , namespace : String ) : StateFlowStore A wrapper StateFlowStore that prefixes every key with a namespace. OnDispose Platforms: common class OnDispose ( function : () -> Unit ) : DisposableHandle A Disposable executing the given function on dispose(). OnReactiveStateAttached Platforms: common interface OnReactiveStateAttached Implement this interface to get notified of every ReactiveState added to your object. ReactiveState Platforms: common interface ReactiveState < E : ErrorEvents > : CoroutineLauncher An interface for ViewModels and any other objects that can trigger one-time events/actions and handle errors. Resolver Platforms: common class Resolver ( autoRunner : BaseAutoRunner ) Tracks observables for AutoRunner and CoAutoRunner . SimpleCoroutineLauncher Platforms: common open class SimpleCoroutineLauncher ( launcherScope : CoroutineScope) : CoroutineLauncher Simple default implementation of a CoroutineLauncher which uses a given CoroutineScope. StateFlowStore Platforms: common interface StateFlowStore Base interface for a temporary observable key-value store. StateFlowStoreFactory Platforms: common typealias StateFlowStoreFactory = (CoroutineScope) -> StateFlowStore A factory function creating a StateFlowStore. SuspendMutableValueFlow Platforms: common @ ExperimentalReactiveStateApi () interface SuspendMutableValueFlow < T > : ValueFlow < T > A StateFlow that can be mutated only via suspend functions - in contrast to assigning the value . ValueFlow Platforms: common interface ValueFlow < T > : StateFlow< T > A version of StateFlow that can explicitly trigger value changes without equality checks. WhileUsed Platforms: common class WhileUsed < T >( retentionMillis : Long , destructor : ( T ) -> Unit ?, builder : ( WhileUsedReferenceToken ) -> T ) A reference-counted value that is created on-demand and freed once nobody uses it (whereas by lazy is never freed). WhileUsedReferenceToken Platforms: common class WhileUsedReferenceToken : DisposableGroup The reference token passed to the WhileUsed builder function. Functions \u00b6 Name Summary addDelay Platforms: common fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. autoRun Platforms: common fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > fun CoroutineScope. autoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. childReactiveState Platforms: common fun < E : ErrorEvents , P : ReactiveState E >, RS : ReactiveState < E >> P . childReactiveState (block: () -> RS ): ReadOnlyProperty < Any ?, RS > Creates and attaches a child ReactiveState . coAutoRun Platforms: common fun CoroutineScope. coAutoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. conflatedMap Platforms: common inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend ( T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform Platforms: common inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.( T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker Platforms: common fun Flow Unit >. conflatedWorker (timeoutMillis: Long = 0): Flow< Unit > Executes each lambda in a Flow using conflatedMap . debounceWorker Platforms: common fun Flow Unit >. debounceWorker (timeoutMillis: Long = 0): Flow< Unit > Executes each lambda in a Flow using debounce and map. decrement Platforms: common fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount . derived Platforms: common fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. Platforms: common fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. DisposableGroup Platforms: common fun DisposableGroup (): DisposableGroup Constructs a DisposableGroup . disposeOnCompletionOf Platforms: common fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation). Platforms: common fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). Platforms: common fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). Platforms: common fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). EventNotifier Platforms: common fun < T > EventNotifier (capacity: Int = Channel.UNLIMITED): EventNotifier < T > Creates an EventNotifier . get Platforms: common fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used. Platforms: common fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope). getData Platforms: common fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. handleEvents Platforms: common suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler . increment Platforms: common fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount . incrementFrom Platforms: common suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow . invokeOnCompletion Platforms: common fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher . Platforms: common fun CoroutineContext . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineContext . Platforms: common fun CoroutineScope. invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineScope. latestWorker Platforms: common fun Flow Unit >. latestWorker (timeoutMillis: Long = 0): Flow< Unit > Executes each lambda in a Flow using debounce and mapLatest. lazyProperty Platforms: common fun < T > lazyProperty (block: (property: KProperty <*>) -> T ): ReadOnlyProperty < Any ?, T > A helper for creating a lazily computed ReadOnlyProperty based on a KProperty . MutableFlow Platforms: common fun < T > MutableFlow (capacity: Int = Channel.RENDEZVOUS, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): MutableFlow < T > Creates a MutableFlow . MutableValueFlow Platforms: common fun < T > MutableValueFlow (value: T , setter: ( T ) -> Unit ? = null): MutableValueFlow < T > Instantiates a MutableValueFlow with the given initial value and optional setter to intercept mutations. propertyName Platforms: common inline fun < T > propertyName (crossinline block: (name: String ) -> T ): ReadOnlyProperty < Any ?, T > A lazyProperty that only receives the KProperty.name as its argument. replace Platforms: common fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T Replaces the MutableStateFlow.value with block \u2018s return value. SuspendMutableValueFlow Platforms: common @ ExperimentalReactiveStateApi () fun < T > SuspendMutableValueFlow (value: T , setter: suspend ( T ) -> Unit ): SuspendMutableValueFlow < T > validUntil Platforms: common fun < T > validUntil (invalidateOn: (invalidate: () -> Unit ) -> Any ?): ReadWriteProperty < Any ?, T > Creates an automatically invalidated property. withErrorReporting Platforms: common inline fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, block: () -> Unit ) suspend fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, onError: suspend (error: Throwable ) -> Unit ?, block: suspend () -> Unit ) Executes the given block , catching any errors and reporting them to the given eventNotifier . Platforms: common inline fun withErrorReporting (onError: (error: Throwable ) -> Unit , block: () -> Unit ) Executes the given block , catching any errors and calling onError , but handling CancellationException. Properties \u00b6 Name Summary defaultAutoRunFlowTransformer [common] val defaultAutoRunFlowTransformer : AutoRunFlowTransformer The default CoAutoRunner / derived flow transformer which is: { conflatedWorker() } dispatchers [common] var dispatchers : CoroutineDispatcherConfig The currently active CoroutineDispatcherConfig .","title":"reactivestate"},{"location":"reference/reactivestate/com.ensody.reactivestate/#package-comensodyreactivestate","text":"","title":"Package com.ensody.reactivestate"},{"location":"reference/reactivestate/com.ensody.reactivestate/#types","text":"Name Summary AttachedDisposables Platforms: common interface AttachedDisposables : DisposableHandle A Disposable that can have additional Disposables attached to it, so they are automatically disposed together with this object. AutoRunCallback Platforms: common typealias AutoRunCallback < T > = Resolver .() -> T Observer callback used by autoRun and AutoRunner . AutoRunFlowTransformer Platforms: common typealias AutoRunFlowTransformer = suspend Flow Unit >.() -> Flow< Unit > Collector of the change events used by coAutoRun and CoAutoRunner . AutoRunner Platforms: common class AutoRunner < T >( launcher : CoroutineLauncher , onChange : AutoRunOnChangeCallback < T >?, flowTransformer : AutoRunFlowTransformer , observer : AutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. AutoRunnerObservable Platforms: common interface AutoRunnerObservable Base interface for observing a hard-coded AutoRunner instance. AutoRunOnChangeCallback Platforms: common typealias AutoRunOnChangeCallback < T > = ( AutoRunner < T >) -> Unit onChange callback used by autoRun and AutoRunner . BaseAutoRunner Platforms: common abstract class BaseAutoRunner : AttachedDisposables Just the minimum interface needed for Resolver . BaseReactiveState Platforms: common open class BaseReactiveState < E : ErrorEvents >( scope : CoroutineScope) : SimpleCoroutineLauncher , ReactiveState < E > Base class/delegate for ViewModels and other objects that can trigger one-time events/actions and handle errors. BaseSuspendMutableValueFlow Platforms: common @ ExperimentalReactiveStateApi () abstract class BaseSuspendMutableValueFlow < T > : ValueFlow < T > , SuspendMutableValueFlow < T > Base class for StateFlows that can be mutated only via suspend functions - in contrast to assigning the value . CoAutoRunCallback Platforms: common typealias CoAutoRunCallback < T > = suspend Resolver .() -> T Observer callback used by suspendable coAutoRun and CoAutoRunner . CoAutoRunner Platforms: common class CoAutoRunner < T >( launcher : CoroutineLauncher , onChange : CoAutoRunOnChangeCallback < T >?, flowTransformer : AutoRunFlowTransformer , dispatcher : CoroutineDispatcher, withLoading : MutableValueFlow < Int >?, observer : CoAutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. CoAutoRunOnChangeCallback Platforms: common typealias CoAutoRunOnChangeCallback < T > = suspend ( CoAutoRunner < T >) -> Unit onChange callback used by suspendable coAutoRun and CoAutoRunner . CoroutineDispatcherConfig Platforms: common interface CoroutineDispatcherConfig Interface for a common set of CoroutineDispatchers. CoroutineLauncher Platforms: common interface CoroutineLauncher Interface for launching coroutines with error handling and loading state tracking. DefaultCoroutineDispatcherConfig Platforms: common object DefaultCoroutineDispatcherConfig : CoroutineDispatcherConfig The default CoroutineDispatcherConfig , mapping to Dispatchers. Disposable Platforms: common typealias Disposable = DisposableHandle An object that can be disposed/deactivated/canceled by calling dispose(). This is an alias for DisposableHandle. DisposableGroup Platforms: common interface DisposableGroup : DisposableHandle A Disposable that can dispose multiple Disposable and Job instances at once. DisposableValue Platforms: common class DisposableValue < T >( value : T , disposer : () -> Unit ) : DisposableHandle A value that must be explicitly dispose d when it\u2019s not needed anymore. ErrorEvents Platforms: common interface ErrorEvents Events interface with a simple onError event (e.g. EventNotifier Platforms: common interface EventNotifier < T > : MutableFlow T .() -> Unit > This is used to send events to an observer. ExperimentalReactiveStateApi Platforms: common annotation class ExperimentalReactiveStateApi This feature is not stable yet and can introduce breaking API changes in minor releases. InMemoryStateFlowStore Platforms: common class InMemoryStateFlowStore : StateFlowStore A StateFlowStore that can be used for unit tests or non-Android parts of multiplatform projects. InternalBaseAutoRunner Platforms: common abstract class InternalBaseAutoRunner ( launcher : CoroutineLauncher , flowTransformer : AutoRunFlowTransformer ) : BaseAutoRunner JobDisposable Platforms: common class JobDisposable ( job : Job) : DisposableHandle A Disposable wrapping a Job. MutableFlow Platforms: common interface MutableFlow < T > : Flow< T > , FlowCollector< T > A Flow where you can emit/ tryEmit values into (backed by a Channel). MutableValueFlow Platforms: common interface MutableValueFlow < T > : ValueFlow < T > , MutableStateFlow< T > A version of MutableStateFlow that provides better support for mutable values via the update operation. NamespacedStateFlowStore Platforms: common class NamespacedStateFlowStore ( store : StateFlowStore , namespace : String ) : StateFlowStore A wrapper StateFlowStore that prefixes every key with a namespace. OnDispose Platforms: common class OnDispose ( function : () -> Unit ) : DisposableHandle A Disposable executing the given function on dispose(). OnReactiveStateAttached Platforms: common interface OnReactiveStateAttached Implement this interface to get notified of every ReactiveState added to your object. ReactiveState Platforms: common interface ReactiveState < E : ErrorEvents > : CoroutineLauncher An interface for ViewModels and any other objects that can trigger one-time events/actions and handle errors. Resolver Platforms: common class Resolver ( autoRunner : BaseAutoRunner ) Tracks observables for AutoRunner and CoAutoRunner . SimpleCoroutineLauncher Platforms: common open class SimpleCoroutineLauncher ( launcherScope : CoroutineScope) : CoroutineLauncher Simple default implementation of a CoroutineLauncher which uses a given CoroutineScope. StateFlowStore Platforms: common interface StateFlowStore Base interface for a temporary observable key-value store. StateFlowStoreFactory Platforms: common typealias StateFlowStoreFactory = (CoroutineScope) -> StateFlowStore A factory function creating a StateFlowStore. SuspendMutableValueFlow Platforms: common @ ExperimentalReactiveStateApi () interface SuspendMutableValueFlow < T > : ValueFlow < T > A StateFlow that can be mutated only via suspend functions - in contrast to assigning the value . ValueFlow Platforms: common interface ValueFlow < T > : StateFlow< T > A version of StateFlow that can explicitly trigger value changes without equality checks. WhileUsed Platforms: common class WhileUsed < T >( retentionMillis : Long , destructor : ( T ) -> Unit ?, builder : ( WhileUsedReferenceToken ) -> T ) A reference-counted value that is created on-demand and freed once nobody uses it (whereas by lazy is never freed). WhileUsedReferenceToken Platforms: common class WhileUsedReferenceToken : DisposableGroup The reference token passed to the WhileUsed builder function.","title":"Types"},{"location":"reference/reactivestate/com.ensody.reactivestate/#functions","text":"Name Summary addDelay Platforms: common fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. autoRun Platforms: common fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > fun CoroutineScope. autoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. childReactiveState Platforms: common fun < E : ErrorEvents , P : ReactiveState E >, RS : ReactiveState < E >> P . childReactiveState (block: () -> RS ): ReadOnlyProperty < Any ?, RS > Creates and attaches a child ReactiveState . coAutoRun Platforms: common fun CoroutineScope. coAutoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. conflatedMap Platforms: common inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend ( T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform Platforms: common inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.( T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker Platforms: common fun Flow Unit >. conflatedWorker (timeoutMillis: Long = 0): Flow< Unit > Executes each lambda in a Flow using conflatedMap . debounceWorker Platforms: common fun Flow Unit >. debounceWorker (timeoutMillis: Long = 0): Flow< Unit > Executes each lambda in a Flow using debounce and map. decrement Platforms: common fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount . derived Platforms: common fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. Platforms: common fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. DisposableGroup Platforms: common fun DisposableGroup (): DisposableGroup Constructs a DisposableGroup . disposeOnCompletionOf Platforms: common fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation). Platforms: common fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). Platforms: common fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). Platforms: common fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). EventNotifier Platforms: common fun < T > EventNotifier (capacity: Int = Channel.UNLIMITED): EventNotifier < T > Creates an EventNotifier . get Platforms: common fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used. Platforms: common fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope). getData Platforms: common fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. handleEvents Platforms: common suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler . increment Platforms: common fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount . incrementFrom Platforms: common suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow . invokeOnCompletion Platforms: common fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher . Platforms: common fun CoroutineContext . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineContext . Platforms: common fun CoroutineScope. invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineScope. latestWorker Platforms: common fun Flow Unit >. latestWorker (timeoutMillis: Long = 0): Flow< Unit > Executes each lambda in a Flow using debounce and mapLatest. lazyProperty Platforms: common fun < T > lazyProperty (block: (property: KProperty <*>) -> T ): ReadOnlyProperty < Any ?, T > A helper for creating a lazily computed ReadOnlyProperty based on a KProperty . MutableFlow Platforms: common fun < T > MutableFlow (capacity: Int = Channel.RENDEZVOUS, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): MutableFlow < T > Creates a MutableFlow . MutableValueFlow Platforms: common fun < T > MutableValueFlow (value: T , setter: ( T ) -> Unit ? = null): MutableValueFlow < T > Instantiates a MutableValueFlow with the given initial value and optional setter to intercept mutations. propertyName Platforms: common inline fun < T > propertyName (crossinline block: (name: String ) -> T ): ReadOnlyProperty < Any ?, T > A lazyProperty that only receives the KProperty.name as its argument. replace Platforms: common fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T Replaces the MutableStateFlow.value with block \u2018s return value. SuspendMutableValueFlow Platforms: common @ ExperimentalReactiveStateApi () fun < T > SuspendMutableValueFlow (value: T , setter: suspend ( T ) -> Unit ): SuspendMutableValueFlow < T > validUntil Platforms: common fun < T > validUntil (invalidateOn: (invalidate: () -> Unit ) -> Any ?): ReadWriteProperty < Any ?, T > Creates an automatically invalidated property. withErrorReporting Platforms: common inline fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, block: () -> Unit ) suspend fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, onError: suspend (error: Throwable ) -> Unit ?, block: suspend () -> Unit ) Executes the given block , catching any errors and reporting them to the given eventNotifier . Platforms: common inline fun withErrorReporting (onError: (error: Throwable ) -> Unit , block: () -> Unit ) Executes the given block , catching any errors and calling onError , but handling CancellationException.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/#properties","text":"Name Summary defaultAutoRunFlowTransformer [common] val defaultAutoRunFlowTransformer : AutoRunFlowTransformer The default CoAutoRunner / derived flow transformer which is: { conflatedWorker() } dispatchers [common] var dispatchers : CoroutineDispatcherConfig The currently active CoroutineDispatcherConfig .","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/","text":"// reactivestate / com.ensody.reactivestate / DisposableGroup DisposableGroup \u00b6 [common] Content fun DisposableGroup (): DisposableGroup More info Constructs a DisposableGroup .","title":" disposable group"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/#disposablegroup","text":"[common] Content fun DisposableGroup (): DisposableGroup More info Constructs a DisposableGroup .","title":"DisposableGroup"},{"location":"reference/reactivestate/com.ensody.reactivestate/-event-notifier/","text":"// reactivestate / com.ensody.reactivestate / EventNotifier EventNotifier \u00b6 [common] Content fun < T > EventNotifier (capacity: Int = Channel.UNLIMITED): EventNotifier < T > More info Creates an EventNotifier .","title":" event notifier"},{"location":"reference/reactivestate/com.ensody.reactivestate/-event-notifier/#eventnotifier","text":"[common] Content fun < T > EventNotifier (capacity: Int = Channel.UNLIMITED): EventNotifier < T > More info Creates an EventNotifier .","title":"EventNotifier"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-flow/","text":"// reactivestate / com.ensody.reactivestate / MutableFlow MutableFlow \u00b6 [common] Content fun < T > MutableFlow (capacity: Int = Channel.RENDEZVOUS, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): MutableFlow < T > More info Creates a MutableFlow .","title":" mutable flow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-flow/#mutableflow","text":"[common] Content fun < T > MutableFlow (capacity: Int = Channel.RENDEZVOUS, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): MutableFlow < T > More info Creates a MutableFlow .","title":"MutableFlow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/","text":"// reactivestate / com.ensody.reactivestate / MutableValueFlow MutableValueFlow \u00b6 [common] Content fun < T > MutableValueFlow (value: T , setter: ( T ) -> Unit ? = null): MutableValueFlow < T > More info Instantiates a MutableValueFlow with the given initial value and optional setter to intercept mutations.","title":" mutable value flow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/#mutablevalueflow","text":"[common] Content fun < T > MutableValueFlow (value: T , setter: ( T ) -> Unit ? = null): MutableValueFlow < T > More info Instantiates a MutableValueFlow with the given initial value and optional setter to intercept mutations.","title":"MutableValueFlow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/","text":"// reactivestate / com.ensody.reactivestate / SuspendMutableValueFlow SuspendMutableValueFlow \u00b6 [common] Content @ ExperimentalReactiveStateApi () fun < T > SuspendMutableValueFlow (value: T , setter: suspend ( T ) -> Unit ): SuspendMutableValueFlow < T >","title":" suspend mutable value flow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/#suspendmutablevalueflow","text":"[common] Content @ ExperimentalReactiveStateApi () fun < T > SuspendMutableValueFlow (value: T , setter: suspend ( T ) -> Unit ): SuspendMutableValueFlow < T >","title":"SuspendMutableValueFlow"},{"location":"reference/reactivestate/com.ensody.reactivestate/add-delay/","text":"// reactivestate / com.ensody.reactivestate / addDelay addDelay \u00b6 [common] Content fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > More info Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op.","title":"Add delay"},{"location":"reference/reactivestate/com.ensody.reactivestate/add-delay/#adddelay","text":"[common] Content fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > More info Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op.","title":"addDelay"},{"location":"reference/reactivestate/com.ensody.reactivestate/auto-run/","text":"// reactivestate / com.ensody.reactivestate / autoRun autoRun \u00b6 [common] Content fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineLauncher \u2018s scope completes. See AutoRunner for more details. Parameters \u00b6 common onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [common] Content fun CoroutineScope. autoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineScope completes. See AutoRunner for more details. Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables.","title":"Auto run"},{"location":"reference/reactivestate/com.ensody.reactivestate/auto-run/#autorun","text":"[common] Content fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineLauncher \u2018s scope completes. See AutoRunner for more details.","title":"autoRun"},{"location":"reference/reactivestate/com.ensody.reactivestate/auto-run/#parameters","text":"common onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [common] Content fun CoroutineScope. autoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineScope completes. See AutoRunner for more details.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/auto-run/#parameters_1","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/child-reactive-state/","text":"// reactivestate / com.ensody.reactivestate / childReactiveState childReactiveState \u00b6 [common] Content fun < E : ErrorEvents , P : ReactiveState E >, RS : ReactiveState < E >> P . childReactiveState (block: () -> RS ): ReadOnlyProperty < Any ?, RS > More info Creates and attaches a child ReactiveState . This merges the child\u2019s ReactiveState.eventNotifier and ReactiveState.loading into the parent. Example: // The parent has to also implement the child events interface ParentEvents : ChildEvents { fun onSomeEvent() } class ParentViewModel(scope: CoroutineScope) : BaseReactiveState (scope) { val childViewModel by childReactiveState { ChildViewModel(scope) } } interface ChildEvents : ErrorEvents { fun onSomeChildEvent() } class ChildViewModel(scope: CoroutineScope) : BaseReactiveState (scope) { init { launch { // \u2026 eventNotifier { onSomeChildEvent() } } } }","title":"Child reactive state"},{"location":"reference/reactivestate/com.ensody.reactivestate/child-reactive-state/#childreactivestate","text":"[common] Content fun < E : ErrorEvents , P : ReactiveState E >, RS : ReactiveState < E >> P . childReactiveState (block: () -> RS ): ReadOnlyProperty < Any ?, RS > More info Creates and attaches a child ReactiveState . This merges the child\u2019s ReactiveState.eventNotifier and ReactiveState.loading into the parent. Example: // The parent has to also implement the child events interface ParentEvents : ChildEvents { fun onSomeEvent() } class ParentViewModel(scope: CoroutineScope) : BaseReactiveState (scope) { val childViewModel by childReactiveState { ChildViewModel(scope) } } interface ChildEvents : ErrorEvents { fun onSomeChildEvent() } class ChildViewModel(scope: CoroutineScope) : BaseReactiveState (scope) { init { launch { // \u2026 eventNotifier { onSomeChildEvent() } } } }","title":"childReactiveState"},{"location":"reference/reactivestate/com.ensody.reactivestate/co-auto-run/","text":"// reactivestate / com.ensody.reactivestate / coAutoRun coAutoRun \u00b6 [common] Content fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineLauncher \u2018s scope completes. See AutoRunner for more details. Parameters \u00b6 common onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. [common] Content fun CoroutineScope. coAutoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineScope completes. See AutoRunner for more details. Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. observer The callback which is used to track the observables.","title":"Co auto run"},{"location":"reference/reactivestate/com.ensody.reactivestate/co-auto-run/#coautorun","text":"[common] Content fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineLauncher \u2018s scope completes. See AutoRunner for more details.","title":"coAutoRun"},{"location":"reference/reactivestate/com.ensody.reactivestate/co-auto-run/#parameters","text":"common onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. [common] Content fun CoroutineScope. coAutoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineScope completes. See AutoRunner for more details.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/co-auto-run/#parameters_1","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/conflated-map/","text":"// reactivestate / com.ensody.reactivestate / conflatedMap conflatedMap \u00b6 [common] Content inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend ( T ) -> R ): Flow< R > More info Maps a conflated Flow with timeoutMillis delay between the first and last element. Maps first and last element and intermediate when possible. The first map starts immediately and we throw away all intermediate changes until the computation is finished and then we map again for the last change that happened in the meantime. Parameters \u00b6 common timeoutMillis Additional delay before the last element is mapped (throwing away intermediate elements).","title":"Conflated map"},{"location":"reference/reactivestate/com.ensody.reactivestate/conflated-map/#conflatedmap","text":"[common] Content inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend ( T ) -> R ): Flow< R > More info Maps a conflated Flow with timeoutMillis delay between the first and last element. Maps first and last element and intermediate when possible. The first map starts immediately and we throw away all intermediate changes until the computation is finished and then we map again for the last change that happened in the meantime.","title":"conflatedMap"},{"location":"reference/reactivestate/com.ensody.reactivestate/conflated-map/#parameters","text":"common timeoutMillis Additional delay before the last element is mapped (throwing away intermediate elements).","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/conflated-transform/","text":"// reactivestate / com.ensody.reactivestate / conflatedTransform conflatedTransform \u00b6 [common] Content inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.( T ) -> Unit ): Flow< R > More info Transforms a conflated Flow with timeoutMillis delay between the first and last element.","title":"Conflated transform"},{"location":"reference/reactivestate/com.ensody.reactivestate/conflated-transform/#conflatedtransform","text":"[common] Content inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.( T ) -> Unit ): Flow< R > More info Transforms a conflated Flow with timeoutMillis delay between the first and last element.","title":"conflatedTransform"},{"location":"reference/reactivestate/com.ensody.reactivestate/conflated-worker/","text":"// reactivestate / com.ensody.reactivestate / conflatedWorker conflatedWorker \u00b6 [common] Content fun Flow Unit >. conflatedWorker (timeoutMillis: Long = 0): Flow< Unit > More info Executes each lambda in a Flow using conflatedMap . Computes first and last element and intermediate when possible. The first computation starts immediately and we throw away all intermediate changes until the computation is finished and then recompute again for the last change that happened in the meantime. This is useful e.g. when you have a constant stream of events (e.g. WebSocket change notifications, keyboard input, mouse moved, etc.) and you want to show intermediate results. If you only want to show the latest result you can use latestWorker . Parameters \u00b6 common timeoutMillis Additional delay before the last element is computed (throwing away intermediate elements).","title":"Conflated worker"},{"location":"reference/reactivestate/com.ensody.reactivestate/conflated-worker/#conflatedworker","text":"[common] Content fun Flow Unit >. conflatedWorker (timeoutMillis: Long = 0): Flow< Unit > More info Executes each lambda in a Flow using conflatedMap . Computes first and last element and intermediate when possible. The first computation starts immediately and we throw away all intermediate changes until the computation is finished and then recompute again for the last change that happened in the meantime. This is useful e.g. when you have a constant stream of events (e.g. WebSocket change notifications, keyboard input, mouse moved, etc.) and you want to show intermediate results. If you only want to show the latest result you can use latestWorker .","title":"conflatedWorker"},{"location":"reference/reactivestate/com.ensody.reactivestate/conflated-worker/#parameters","text":"common timeoutMillis Additional delay before the last element is computed (throwing away intermediate elements).","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/debounce-worker/","text":"// reactivestate / com.ensody.reactivestate / debounceWorker debounceWorker \u00b6 [common] Content fun Flow Unit >. debounceWorker (timeoutMillis: Long = 0): Flow< Unit > More info Executes each lambda in a Flow using debounce and map. Warning: This will not compute anything if new entries keep coming in at a rate faster than timeoutMillis ! This also adds a delay before the first execution! Especially in UIs you\u2019ll usually want to: execute as quickly as possible, so that the UI feels snappy get intermediate results to provide some feedback This is why you\u2019ll usually want to use conflatedWorker . Parameters \u00b6 common timeoutMillis The debounce timeout.","title":"Debounce worker"},{"location":"reference/reactivestate/com.ensody.reactivestate/debounce-worker/#debounceworker","text":"[common] Content fun Flow Unit >. debounceWorker (timeoutMillis: Long = 0): Flow< Unit > More info Executes each lambda in a Flow using debounce and map. Warning: This will not compute anything if new entries keep coming in at a rate faster than timeoutMillis ! This also adds a delay before the first execution! Especially in UIs you\u2019ll usually want to: execute as quickly as possible, so that the UI feels snappy get intermediate results to provide some feedback This is why you\u2019ll usually want to use conflatedWorker .","title":"debounceWorker"},{"location":"reference/reactivestate/com.ensody.reactivestate/debounce-worker/#parameters","text":"common timeoutMillis The debounce timeout.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/decrement/","text":"// reactivestate / com.ensody.reactivestate / decrement decrement \u00b6 [common] Content fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int More info Atomically decrement this MutableValueFlow by amount .","title":"Decrement"},{"location":"reference/reactivestate/com.ensody.reactivestate/decrement/#decrement","text":"[common] Content fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int More info Atomically decrement this MutableValueFlow by amount .","title":"decrement"},{"location":"reference/reactivestate/com.ensody.reactivestate/default-auto-run-flow-transformer/","text":"// reactivestate / com.ensody.reactivestate / defaultAutoRunFlowTransformer defaultAutoRunFlowTransformer \u00b6 [common] Content val defaultAutoRunFlowTransformer : AutoRunFlowTransformer More info The default CoAutoRunner / derived flow transformer which is: { conflatedWorker() }","title":"Default auto run flow transformer"},{"location":"reference/reactivestate/com.ensody.reactivestate/default-auto-run-flow-transformer/#defaultautorunflowtransformer","text":"[common] Content val defaultAutoRunFlowTransformer : AutoRunFlowTransformer More info The default CoAutoRunner / derived flow transformer which is: { conflatedWorker() }","title":"defaultAutoRunFlowTransformer"},{"location":"reference/reactivestate/com.ensody.reactivestate/derived/","text":"// reactivestate / com.ensody.reactivestate / derived derived \u00b6 [common] Content fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), observer: AutoRunCallback < T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. [common] Content fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed. Parameters \u00b6 common initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. [common] Content fun < T > CoroutineScope. derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed. Parameters \u00b6 common initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to null. observer The callback which is used to track the observables.","title":"Derived"},{"location":"reference/reactivestate/com.ensody.reactivestate/derived/#derived","text":"[common] Content fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), observer: AutoRunCallback < T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. [common] Content fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed.","title":"derived"},{"location":"reference/reactivestate/com.ensody.reactivestate/derived/#parameters","text":"common initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. [common] Content fun < T > CoroutineScope. derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/derived/#parameters_1","text":"common initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to null. observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/dispatchers/","text":"// reactivestate / com.ensody.reactivestate / dispatchers dispatchers \u00b6 [common] Content var dispatchers : CoroutineDispatcherConfig More info The currently active CoroutineDispatcherConfig .","title":"Dispatchers"},{"location":"reference/reactivestate/com.ensody.reactivestate/dispatchers/#dispatchers","text":"[common] Content var dispatchers : CoroutineDispatcherConfig More info The currently active CoroutineDispatcherConfig .","title":"dispatchers"},{"location":"reference/reactivestate/com.ensody.reactivestate/dispose-on-completion-of/","text":"// reactivestate / com.ensody.reactivestate / disposeOnCompletionOf disposeOnCompletionOf \u00b6 [common] Content fun Disposable . disposeOnCompletionOf (job: Job): Disposable More info Disposes the Disposable when Job completes (including cancellation). [common] Content fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable More info Disposes the Disposable when CoroutineContext completes (including cancellation). [common] Content fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable More info Disposes the Disposable when CoroutineScope completes (including cancellation). [common] Content fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable More info Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Dispose on completion of"},{"location":"reference/reactivestate/com.ensody.reactivestate/dispose-on-completion-of/#disposeoncompletionof","text":"[common] Content fun Disposable . disposeOnCompletionOf (job: Job): Disposable More info Disposes the Disposable when Job completes (including cancellation). [common] Content fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable More info Disposes the Disposable when CoroutineContext completes (including cancellation). [common] Content fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable More info Disposes the Disposable when CoroutineScope completes (including cancellation). [common] Content fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable More info Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"disposeOnCompletionOf"},{"location":"reference/reactivestate/com.ensody.reactivestate/get-data/","text":"// reactivestate / com.ensody.reactivestate / getData getData \u00b6 [common] Content fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> More info For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"Get data"},{"location":"reference/reactivestate/com.ensody.reactivestate/get-data/#getdata","text":"[common] Content fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> More info For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"getData"},{"location":"reference/reactivestate/com.ensody.reactivestate/get/","text":"// reactivestate / com.ensody.reactivestate / get get \u00b6 [common] Content fun < T > Resolver . get (data: StateFlow< T >): T More info Returns StateFlow.value and tracks the observable (on the MainScope). [common] Content fun < T > Resolver . get (data: WhileUsed < T >): T More info Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used.","title":"Get"},{"location":"reference/reactivestate/com.ensody.reactivestate/get/#get","text":"[common] Content fun < T > Resolver . get (data: StateFlow< T >): T More info Returns StateFlow.value and tracks the observable (on the MainScope). [common] Content fun < T > Resolver . get (data: WhileUsed < T >): T More info Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used.","title":"get"},{"location":"reference/reactivestate/com.ensody.reactivestate/handle-events/","text":"// reactivestate / com.ensody.reactivestate / handleEvents handleEvents \u00b6 [common] Content suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) More info Consumes and handles EventNotifier \u2018s events on the given handler . Any errors during event handling will trigger ErrorEvents.onError on the handler .","title":"Handle events"},{"location":"reference/reactivestate/com.ensody.reactivestate/handle-events/#handleevents","text":"[common] Content suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) More info Consumes and handles EventNotifier \u2018s events on the given handler . Any errors during event handling will trigger ErrorEvents.onError on the handler .","title":"handleEvents"},{"location":"reference/reactivestate/com.ensody.reactivestate/increment-from/","text":"// reactivestate / com.ensody.reactivestate / incrementFrom incrementFrom \u00b6 [common] Content suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) More info Keeps this incremented increment by the latest value in the given flow . For example, if this MutableValueFlow is initially set to 1 and flow is set to 1, 2, 0 then the value of this MutableValueFlow will be set to 2, then 3, then 1.","title":"Increment from"},{"location":"reference/reactivestate/com.ensody.reactivestate/increment-from/#incrementfrom","text":"[common] Content suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) More info Keeps this incremented increment by the latest value in the given flow . For example, if this MutableValueFlow is initially set to 1 and flow is set to 1, 2, 0 then the value of this MutableValueFlow will be set to 2, then 3, then 1.","title":"incrementFrom"},{"location":"reference/reactivestate/com.ensody.reactivestate/increment/","text":"// reactivestate / com.ensody.reactivestate / increment increment \u00b6 [common] Content fun MutableValueFlow < Int >. increment (amount: Int = 1): Int More info Atomically increment this MutableValueFlow by amount .","title":"Increment"},{"location":"reference/reactivestate/com.ensody.reactivestate/increment/#increment","text":"[common] Content fun MutableValueFlow < Int >. increment (amount: Int = 1): Int More info Atomically increment this MutableValueFlow by amount .","title":"increment"},{"location":"reference/reactivestate/com.ensody.reactivestate/invoke-on-completion/","text":"// reactivestate / com.ensody.reactivestate / invokeOnCompletion invokeOnCompletion \u00b6 [common] Content fun CoroutineContext . invokeOnCompletion (handler: CompletionHandler): Disposable More info Helper for adding a completion handler to a CoroutineContext . [common] Content fun CoroutineScope. invokeOnCompletion (handler: CompletionHandler): Disposable More info Helper for adding a completion handler to a CoroutineScope. [common] Content fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable More info Helper for adding a completion handler to a CoroutineLauncher .","title":"Invoke on completion"},{"location":"reference/reactivestate/com.ensody.reactivestate/invoke-on-completion/#invokeoncompletion","text":"[common] Content fun CoroutineContext . invokeOnCompletion (handler: CompletionHandler): Disposable More info Helper for adding a completion handler to a CoroutineContext . [common] Content fun CoroutineScope. invokeOnCompletion (handler: CompletionHandler): Disposable More info Helper for adding a completion handler to a CoroutineScope. [common] Content fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable More info Helper for adding a completion handler to a CoroutineLauncher .","title":"invokeOnCompletion"},{"location":"reference/reactivestate/com.ensody.reactivestate/latest-worker/","text":"// reactivestate / com.ensody.reactivestate / latestWorker latestWorker \u00b6 [common] Content fun Flow Unit >. latestWorker (timeoutMillis: Long = 0): Flow< Unit > More info Executes each lambda in a Flow using debounce and mapLatest. Warning: This will not compute anything if new entries keep coming in at a rate faster than timeoutMillis ! This also adds a delay before the first execution! Especially in UIs you\u2019ll usually want to: execute as quickly as possible, so that the UI feels snappy get intermediate results to provide some feedback This is why you\u2019ll usually want to use conflatedWorker . Parameters \u00b6 common timeoutMillis The debounce timeout.","title":"Latest worker"},{"location":"reference/reactivestate/com.ensody.reactivestate/latest-worker/#latestworker","text":"[common] Content fun Flow Unit >. latestWorker (timeoutMillis: Long = 0): Flow< Unit > More info Executes each lambda in a Flow using debounce and mapLatest. Warning: This will not compute anything if new entries keep coming in at a rate faster than timeoutMillis ! This also adds a delay before the first execution! Especially in UIs you\u2019ll usually want to: execute as quickly as possible, so that the UI feels snappy get intermediate results to provide some feedback This is why you\u2019ll usually want to use conflatedWorker .","title":"latestWorker"},{"location":"reference/reactivestate/com.ensody.reactivestate/latest-worker/#parameters","text":"common timeoutMillis The debounce timeout.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/lazy-property/","text":"// reactivestate / com.ensody.reactivestate / lazyProperty lazyProperty \u00b6 [common] Content fun < T > lazyProperty (block: (property: KProperty <*>) -> T ): ReadOnlyProperty < Any ?, T > More info A helper for creating a lazily computed ReadOnlyProperty based on a KProperty .","title":"Lazy property"},{"location":"reference/reactivestate/com.ensody.reactivestate/lazy-property/#lazyproperty","text":"[common] Content fun < T > lazyProperty (block: (property: KProperty <*>) -> T ): ReadOnlyProperty < Any ?, T > More info A helper for creating a lazily computed ReadOnlyProperty based on a KProperty .","title":"lazyProperty"},{"location":"reference/reactivestate/com.ensody.reactivestate/property-name/","text":"// reactivestate / com.ensody.reactivestate / propertyName propertyName \u00b6 [common] Content inline fun < T > propertyName (crossinline block: (name: String ) -> T ): ReadOnlyProperty < Any ?, T > More info A lazyProperty that only receives the KProperty.name as its argument.","title":"Property name"},{"location":"reference/reactivestate/com.ensody.reactivestate/property-name/#propertyname","text":"[common] Content inline fun < T > propertyName (crossinline block: (name: String ) -> T ): ReadOnlyProperty < Any ?, T > More info A lazyProperty that only receives the KProperty.name as its argument.","title":"propertyName"},{"location":"reference/reactivestate/com.ensody.reactivestate/replace/","text":"// reactivestate / com.ensody.reactivestate / replace replace \u00b6 [common] Content fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T More info Replaces the MutableStateFlow.value with block \u2018s return value. WARNING: This method is not thread-safe! Use MutableValueFlow.replaceLocked if you want to guarantee correctness under concurrency. This is a simple helper for the common case where you want to copy() a data class: data class Foo(val num: Int) val stateFlow = MutableStateFlow(Foo(3)) stateFlow.replace { copy(num = 5) } Return \u00b6 The previous value before replacing.","title":"Replace"},{"location":"reference/reactivestate/com.ensody.reactivestate/replace/#replace","text":"[common] Content fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T More info Replaces the MutableStateFlow.value with block \u2018s return value. WARNING: This method is not thread-safe! Use MutableValueFlow.replaceLocked if you want to guarantee correctness under concurrency. This is a simple helper for the common case where you want to copy() a data class: data class Foo(val num: Int) val stateFlow = MutableStateFlow(Foo(3)) stateFlow.replace { copy(num = 5) }","title":"replace"},{"location":"reference/reactivestate/com.ensody.reactivestate/replace/#return","text":"The previous value before replacing.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate/valid-until/","text":"// reactivestate / com.ensody.reactivestate / validUntil validUntil \u00b6 [common] Content fun < T > validUntil (invalidateOn: (invalidate: () -> Unit ) -> Any ?): ReadWriteProperty < Any ?, T > More info Creates an automatically invalidated property. The property starts out invalid and must be set to become valid. When it becomes invalidated you have to set it, again, to make it valid. The property is invalidated when the provided invalidateOn function calls the lambda function passed as its first argument. Example: class SomeClass { var value by validUntil { invalidate -> onSomeEvent { invalidate() } } } Android-specific example: class MainFragment : Fragment() { private var binding by validUntil (::onDestroyView) 1 2 3 4 5 6 7 8 9 override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { binding = MainFragmentBinding.inflate(inflater, container, false) val username = binding.username // ... return binding.root } }","title":"Valid until"},{"location":"reference/reactivestate/com.ensody.reactivestate/valid-until/#validuntil","text":"[common] Content fun < T > validUntil (invalidateOn: (invalidate: () -> Unit ) -> Any ?): ReadWriteProperty < Any ?, T > More info Creates an automatically invalidated property. The property starts out invalid and must be set to become valid. When it becomes invalidated you have to set it, again, to make it valid. The property is invalidated when the provided invalidateOn function calls the lambda function passed as its first argument. Example: class SomeClass { var value by validUntil { invalidate -> onSomeEvent { invalidate() } } } Android-specific example: class MainFragment : Fragment() { private var binding by validUntil (::onDestroyView) 1 2 3 4 5 6 7 8 9 override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { binding = MainFragmentBinding.inflate(inflater, container, false) val username = binding.username // ... return binding.root } }","title":"validUntil"},{"location":"reference/reactivestate/com.ensody.reactivestate/with-error-reporting/","text":"// reactivestate / com.ensody.reactivestate / withErrorReporting withErrorReporting \u00b6 [common] Content suspend fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, onError: suspend (error: Throwable ) -> Unit ?, block: suspend () -> Unit ) inline fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, block: () -> Unit ) More info Executes the given block , catching any errors and reporting them to the given eventNotifier . [common] Content inline fun withErrorReporting (onError: (error: Throwable ) -> Unit , block: () -> Unit ) More info Executes the given block , catching any errors and calling onError , but handling CancellationException.","title":"With error reporting"},{"location":"reference/reactivestate/com.ensody.reactivestate/with-error-reporting/#witherrorreporting","text":"[common] Content suspend fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, onError: suspend (error: Throwable ) -> Unit ?, block: suspend () -> Unit ) inline fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, block: () -> Unit ) More info Executes the given block , catching any errors and reporting them to the given eventNotifier . [common] Content inline fun withErrorReporting (onError: (error: Throwable ) -> Unit , block: () -> Unit ) More info Executes the given block , catching any errors and calling onError , but handling CancellationException.","title":"withErrorReporting"},{"location":"reference/reactivestate/com.ensody.reactivestate/-attached-disposables/","text":"// reactivestate / com.ensody.reactivestate / AttachedDisposables AttachedDisposables \u00b6 [common] interface AttachedDisposables : DisposableHandle A Disposable that can have additional Disposables attached to it, so they are automatically disposed together with this object. Functions \u00b6 Name Summary dispose Platforms: common open override fun dispose () Default implementation disposing the attachedDisposables . Properties \u00b6 Name Summary attachedDisposables [common] abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. Inheritors \u00b6 Name BaseAutoRunner","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-attached-disposables/#attacheddisposables","text":"[common] interface AttachedDisposables : DisposableHandle A Disposable that can have additional Disposables attached to it, so they are automatically disposed together with this object.","title":"AttachedDisposables"},{"location":"reference/reactivestate/com.ensody.reactivestate/-attached-disposables/#functions","text":"Name Summary dispose Platforms: common open override fun dispose () Default implementation disposing the attachedDisposables .","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-attached-disposables/#properties","text":"Name Summary attachedDisposables [common] abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed.","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-attached-disposables/#inheritors","text":"Name BaseAutoRunner","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-attached-disposables/attached-disposables/","text":"// reactivestate / com.ensody.reactivestate / AttachedDisposables / attachedDisposables attachedDisposables \u00b6 [common] Content abstract val attachedDisposables : DisposableGroup More info The attached disposables which should be auto-disposed when this object is disposed.","title":"Attached disposables"},{"location":"reference/reactivestate/com.ensody.reactivestate/-attached-disposables/attached-disposables/#attacheddisposables","text":"[common] Content abstract val attachedDisposables : DisposableGroup More info The attached disposables which should be auto-disposed when this object is disposed.","title":"attachedDisposables"},{"location":"reference/reactivestate/com.ensody.reactivestate/-attached-disposables/dispose/","text":"// reactivestate / com.ensody.reactivestate / AttachedDisposables / dispose dispose \u00b6 [common] Content open override fun dispose () More info Default implementation disposing the attachedDisposables .","title":"Dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-attached-disposables/dispose/#dispose","text":"[common] Content open override fun dispose () More info Default implementation disposing the attachedDisposables .","title":"dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/","text":"// reactivestate / com.ensody.reactivestate / AutoRunner AutoRunner \u00b6 [common] class AutoRunner < T >( launcher : CoroutineLauncher , onChange : AutoRunOnChangeCallback < T >?, flowTransformer : AutoRunFlowTransformer , observer : AutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the synchronous version. See CoAutoRunner for the suspension function based version. Given an observer, this class will automatically register itself as a listener and keep track of the observables which observer depends on. You have to call run once to start watching. To stop watching, you should call dispose. Instead of instantiating an AutoRunner directly you\u2019ll usually want to use an autoRun helper. Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. observer The callback which is used to track the observables. Constructors \u00b6 AutoRunner [common] fun AutoRunner (launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, observer: AutoRunCallback < T >)The CoroutineLauncher to use. Functions \u00b6 Name Summary dispose Platforms: common open override fun dispose () Stops watching observables. run Platforms: common fun run (): T Calls observer and tracks its dependencies. triggerChange Platforms: common open override fun triggerChange () Properties \u00b6 Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher resolver [common] internal open override var resolver : Resolver","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/#autorunner","text":"[common] class AutoRunner < T >( launcher : CoroutineLauncher , onChange : AutoRunOnChangeCallback < T >?, flowTransformer : AutoRunFlowTransformer , observer : AutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the synchronous version. See CoAutoRunner for the suspension function based version. Given an observer, this class will automatically register itself as a listener and keep track of the observables which observer depends on. You have to call run once to start watching. To stop watching, you should call dispose. Instead of instantiating an AutoRunner directly you\u2019ll usually want to use an autoRun helper.","title":"AutoRunner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/#parameters","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/#constructors","text":"AutoRunner [common] fun AutoRunner (launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, observer: AutoRunCallback < T >)The CoroutineLauncher to use.","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/#functions","text":"Name Summary dispose Platforms: common open override fun dispose () Stops watching observables. run Platforms: common fun run (): T Calls observer and tracks its dependencies. triggerChange Platforms: common open override fun triggerChange ()","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/#properties","text":"Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher resolver [common] internal open override var resolver : Resolver","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/-auto-runner/","text":"// reactivestate / com.ensody.reactivestate / AutoRunner / AutoRunner AutoRunner \u00b6 [common] Content fun AutoRunner (launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, observer: AutoRunCallback < T >) More info Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. observer The callback which is used to track the observables.","title":" auto runner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/-auto-runner/#autorunner","text":"[common] Content fun AutoRunner (launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, observer: AutoRunCallback < T >) More info","title":"AutoRunner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/-auto-runner/#parameters","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/run/","text":"// reactivestate / com.ensody.reactivestate / AutoRunner / run run \u00b6 [common] Content fun run (): T More info Calls observer and tracks its dependencies.","title":"Run"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner/run/#run","text":"[common] Content fun run (): T More info Calls observer and tracks its dependencies.","title":"run"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner-observable/","text":"// reactivestate / com.ensody.reactivestate / AutoRunnerObservable AutoRunnerObservable \u00b6 [common] interface AutoRunnerObservable Base interface for observing a hard-coded AutoRunner instance. You can use this to wrap actual observables (e.g. Android\u2019s LiveData). Functions \u00b6 Name Summary addObserver Platforms: common abstract fun addObserver () removeObserver Platforms: common abstract fun removeObserver ()","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner-observable/#autorunnerobservable","text":"[common] interface AutoRunnerObservable Base interface for observing a hard-coded AutoRunner instance. You can use this to wrap actual observables (e.g. Android\u2019s LiveData).","title":"AutoRunnerObservable"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner-observable/#functions","text":"Name Summary addObserver Platforms: common abstract fun addObserver () removeObserver Platforms: common abstract fun removeObserver ()","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner-observable/add-observer/","text":"// reactivestate / com.ensody.reactivestate / AutoRunnerObservable / addObserver addObserver \u00b6 [common] Content abstract fun addObserver ()","title":"Add observer"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner-observable/add-observer/#addobserver","text":"[common] Content abstract fun addObserver ()","title":"addObserver"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner-observable/remove-observer/","text":"// reactivestate / com.ensody.reactivestate / AutoRunnerObservable / removeObserver removeObserver \u00b6 [common] Content abstract fun removeObserver ()","title":"Remove observer"},{"location":"reference/reactivestate/com.ensody.reactivestate/-auto-runner-observable/remove-observer/#removeobserver","text":"[common] Content abstract fun removeObserver ()","title":"removeObserver"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/","text":"// reactivestate / com.ensody.reactivestate / BaseAutoRunner BaseAutoRunner \u00b6 [common] abstract class BaseAutoRunner : AttachedDisposables Just the minimum interface needed for Resolver . No generic types. Constructors \u00b6 BaseAutoRunner [common] fun BaseAutoRunner () Functions \u00b6 Name Summary dispose Platforms: common open override fun dispose () Default implementation disposing the attachedDisposables . triggerChange Platforms: common abstract fun triggerChange () Properties \u00b6 Name Summary attachedDisposables [common] abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] abstract val launcher : CoroutineLauncher Inheritors \u00b6 Name InternalBaseAutoRunner","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/#baseautorunner","text":"[common] abstract class BaseAutoRunner : AttachedDisposables Just the minimum interface needed for Resolver . No generic types.","title":"BaseAutoRunner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/#constructors","text":"BaseAutoRunner [common] fun BaseAutoRunner ()","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/#functions","text":"Name Summary dispose Platforms: common open override fun dispose () Default implementation disposing the attachedDisposables . triggerChange Platforms: common abstract fun triggerChange ()","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/#properties","text":"Name Summary attachedDisposables [common] abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] abstract val launcher : CoroutineLauncher","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/#inheritors","text":"Name InternalBaseAutoRunner","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/-base-auto-runner/","text":"// reactivestate / com.ensody.reactivestate / BaseAutoRunner / BaseAutoRunner BaseAutoRunner \u00b6 [common] Content fun BaseAutoRunner ()","title":" base auto runner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/-base-auto-runner/#baseautorunner","text":"[common] Content fun BaseAutoRunner ()","title":"BaseAutoRunner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/launcher/","text":"// reactivestate / com.ensody.reactivestate / BaseAutoRunner / launcher launcher \u00b6 [common] Content abstract val launcher : CoroutineLauncher","title":"Launcher"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/launcher/#launcher","text":"[common] Content abstract val launcher : CoroutineLauncher","title":"launcher"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/trigger-change/","text":"// reactivestate / com.ensody.reactivestate / BaseAutoRunner / triggerChange triggerChange \u00b6 [common] Content abstract fun triggerChange ()","title":"Trigger change"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-auto-runner/trigger-change/#triggerchange","text":"[common] Content abstract fun triggerChange ()","title":"triggerChange"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/","text":"// reactivestate / com.ensody.reactivestate / BaseReactiveState BaseReactiveState \u00b6 [common] open class BaseReactiveState < E : ErrorEvents >( scope : CoroutineScope) : SimpleCoroutineLauncher , ReactiveState < E > Base class/delegate for ViewModels and other objects that can trigger one-time events/actions and handle errors. Make sure you always launch coroutines via launch (instead of the scope) to get automatic error handling. Example: // You can compose multiple events interfaces with simple inheritance (more elegant than sealed classes) interface FooEvents : ErrorEvents, OtherEvents, AndMoreEvents { fun onUserIsUnauthorized() } class FooViewModel(scope: CoroutineScope) : BaseReactiveState (scope) { private val _messages = MutableStateFlow >(emptyList()) val messages: StateFlow > = _messages 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 init { loadMessages() } fun loadMessages() { launch { // Let's pretend this function returns null for unauthorized requests val messages = retrieveMessagesFromBackend() if (messages == null) { eventNotifier { onUserIsUnauthorized() } } else { _messages.value = messages } } } } Constructors \u00b6 BaseReactiveState [common] fun BaseReactiveState (scope: CoroutineScope) Functions \u00b6 Name Summary launch Platforms: common abstract fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. onError Platforms: common open override fun onError (error: Throwable ) Properties \u00b6 Name Summary eventNotifier [common] open override val eventNotifier : EventNotifier < E > launcherScope [common] abstract val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int >The default loading tracker.","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/#basereactivestate","text":"[common] open class BaseReactiveState < E : ErrorEvents >( scope : CoroutineScope) : SimpleCoroutineLauncher , ReactiveState < E > Base class/delegate for ViewModels and other objects that can trigger one-time events/actions and handle errors. Make sure you always launch coroutines via launch (instead of the scope) to get automatic error handling. Example: // You can compose multiple events interfaces with simple inheritance (more elegant than sealed classes) interface FooEvents : ErrorEvents, OtherEvents, AndMoreEvents { fun onUserIsUnauthorized() } class FooViewModel(scope: CoroutineScope) : BaseReactiveState (scope) { private val _messages = MutableStateFlow >(emptyList()) val messages: StateFlow > = _messages 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 init { loadMessages() } fun loadMessages() { launch { // Let's pretend this function returns null for unauthorized requests val messages = retrieveMessagesFromBackend() if (messages == null) { eventNotifier { onUserIsUnauthorized() } } else { _messages.value = messages } } } }","title":"BaseReactiveState"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/#constructors","text":"BaseReactiveState [common] fun BaseReactiveState (scope: CoroutineScope)","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/#functions","text":"Name Summary launch Platforms: common abstract fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. onError Platforms: common open override fun onError (error: Throwable )","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/#properties","text":"Name Summary eventNotifier [common] open override val eventNotifier : EventNotifier < E > launcherScope [common] abstract val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int >The default loading tracker.","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/-base-reactive-state/","text":"// reactivestate / com.ensody.reactivestate / BaseReactiveState / BaseReactiveState BaseReactiveState \u00b6 [common] Content fun BaseReactiveState (scope: CoroutineScope)","title":" base reactive state"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/-base-reactive-state/#basereactivestate","text":"[common] Content fun BaseReactiveState (scope: CoroutineScope)","title":"BaseReactiveState"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/event-notifier/","text":"// reactivestate / com.ensody.reactivestate / BaseReactiveState / eventNotifier eventNotifier \u00b6 [common] Content open override val eventNotifier : EventNotifier < E >","title":"Event notifier"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/event-notifier/#eventnotifier","text":"[common] Content open override val eventNotifier : EventNotifier < E >","title":"eventNotifier"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/on-error/","text":"// reactivestate / com.ensody.reactivestate / BaseReactiveState / onError onError \u00b6 [common] Content open override fun onError (error: Throwable )","title":"On error"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-reactive-state/on-error/#onerror","text":"[common] Content open override fun onError (error: Throwable )","title":"onError"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/","text":"// reactivestate / com.ensody.reactivestate / BaseSuspendMutableValueFlow BaseSuspendMutableValueFlow \u00b6 [common] @ ExperimentalReactiveStateApi () abstract class BaseSuspendMutableValueFlow < T > : ValueFlow < T > , SuspendMutableValueFlow < T > Base class for StateFlows that can be mutated only via suspend functions - in contrast to assigning the value . This is useful e.g. for values backed by some storage/backend system. See also \u00b6 common com.ensody.reactivestate.SuspendMutableValueFlow for a simple lambda-based implementation. Constructors \u00b6 BaseSuspendMutableValueFlow [common] fun < T > BaseSuspendMutableValueFlow (value: T ) Functions \u00b6 Name Summary collect Platforms: common open suspend override fun collect (collector: FlowCollector< T >) replace Platforms: common open suspend override fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value. set Platforms: common open suspend override fun set (value: T , force: Boolean ) Assigns a new value . update Platforms: common open suspend override fun update (block: ( T ) -> Unit ) Mutates value in-place and notifies listeners. updateThis Platforms: common open suspend override fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. Properties \u00b6 Name Summary replayCache [common] open override val replayCache : List < T > value [common] open override val value : T","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#basesuspendmutablevalueflow","text":"[common] @ ExperimentalReactiveStateApi () abstract class BaseSuspendMutableValueFlow < T > : ValueFlow < T > , SuspendMutableValueFlow < T > Base class for StateFlows that can be mutated only via suspend functions - in contrast to assigning the value . This is useful e.g. for values backed by some storage/backend system.","title":"BaseSuspendMutableValueFlow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#see-also","text":"common com.ensody.reactivestate.SuspendMutableValueFlow for a simple lambda-based implementation.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#constructors","text":"BaseSuspendMutableValueFlow [common] fun < T > BaseSuspendMutableValueFlow (value: T )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#functions","text":"Name Summary collect Platforms: common open suspend override fun collect (collector: FlowCollector< T >) replace Platforms: common open suspend override fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value. set Platforms: common open suspend override fun set (value: T , force: Boolean ) Assigns a new value . update Platforms: common open suspend override fun update (block: ( T ) -> Unit ) Mutates value in-place and notifies listeners. updateThis Platforms: common open suspend override fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#properties","text":"Name Summary replayCache [common] open override val replayCache : List < T > value [common] open override val value : T","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/-base-suspend-mutable-value-flow/","text":"// reactivestate / com.ensody.reactivestate / BaseSuspendMutableValueFlow / BaseSuspendMutableValueFlow BaseSuspendMutableValueFlow \u00b6 [common] Content fun < T > BaseSuspendMutableValueFlow (value: T )","title":" base suspend mutable value flow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/-base-suspend-mutable-value-flow/#basesuspendmutablevalueflow","text":"[common] Content fun < T > BaseSuspendMutableValueFlow (value: T )","title":"BaseSuspendMutableValueFlow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/replace/","text":"// reactivestate / com.ensody.reactivestate / BaseSuspendMutableValueFlow / replace replace \u00b6 [common] Content open suspend override fun replace (block: T .() -> T ) More info Replaces the value with block \u2018s return value.","title":"Replace"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/replace/#replace","text":"[common] Content open suspend override fun replace (block: T .() -> T ) More info Replaces the value with block \u2018s return value.","title":"replace"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/set/","text":"// reactivestate / com.ensody.reactivestate / BaseSuspendMutableValueFlow / set set \u00b6 [common] Content open suspend override fun set (value: T , force: Boolean ) More info Assigns a new value . Parameters \u00b6 common value The new value to be assigned. force Whether to assign even if value is unchanged. Defaults to false, behaving like MutableStateFlow.","title":"Set"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/set/#set","text":"[common] Content open suspend override fun set (value: T , force: Boolean ) More info Assigns a new value .","title":"set"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/set/#parameters","text":"common value The new value to be assigned. force Whether to assign even if value is unchanged. Defaults to false, behaving like MutableStateFlow.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/update-this/","text":"// reactivestate / com.ensody.reactivestate / BaseSuspendMutableValueFlow / updateThis updateThis \u00b6 [common] Content open suspend override fun updateThis (block: T .() -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed via this.","title":"Update this"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/update-this/#updatethis","text":"[common] Content open suspend override fun updateThis (block: T .() -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed via this.","title":"updateThis"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/update/","text":"// reactivestate / com.ensody.reactivestate / BaseSuspendMutableValueFlow / update update \u00b6 [common] Content open suspend override fun update (block: ( T ) -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"Update"},{"location":"reference/reactivestate/com.ensody.reactivestate/-base-suspend-mutable-value-flow/update/#update","text":"[common] Content open suspend override fun update (block: ( T ) -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"update"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/","text":"// reactivestate / com.ensody.reactivestate / CoAutoRunner CoAutoRunner \u00b6 [common] class CoAutoRunner < T >( launcher : CoroutineLauncher , onChange : CoAutoRunOnChangeCallback < T >?, flowTransformer : AutoRunFlowTransformer , dispatcher : CoroutineDispatcher, withLoading : MutableValueFlow < Int >?, observer : CoAutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the suspension function based version. See AutoRunner for the synchronous version. Given an observer, this class will automatically register itself as a listener and keep track of the observables which observer depends on. You have to call run once to start watching. To stop watching, you should call dispose. Instead of instantiating an AutoRunner directly you\u2019ll usually want to use an autoRun helper. Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. Constructors \u00b6 CoAutoRunner [common] fun CoAutoRunner (launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >)The CoroutineLauncher to use. Functions \u00b6 Name Summary dispose Platforms: common open override fun dispose () Stops watching observables. run Platforms: common suspend fun run (): T Calls observer and tracks its dependencies. triggerChange Platforms: common open override fun triggerChange () Properties \u00b6 Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher resolver [common] internal open override var resolver : Resolver","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/#coautorunner","text":"[common] class CoAutoRunner < T >( launcher : CoroutineLauncher , onChange : CoAutoRunOnChangeCallback < T >?, flowTransformer : AutoRunFlowTransformer , dispatcher : CoroutineDispatcher, withLoading : MutableValueFlow < Int >?, observer : CoAutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the suspension function based version. See AutoRunner for the synchronous version. Given an observer, this class will automatically register itself as a listener and keep track of the observables which observer depends on. You have to call run once to start watching. To stop watching, you should call dispose. Instead of instantiating an AutoRunner directly you\u2019ll usually want to use an autoRun helper.","title":"CoAutoRunner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/#parameters","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/#constructors","text":"CoAutoRunner [common] fun CoAutoRunner (launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >)The CoroutineLauncher to use.","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/#functions","text":"Name Summary dispose Platforms: common open override fun dispose () Stops watching observables. run Platforms: common suspend fun run (): T Calls observer and tracks its dependencies. triggerChange Platforms: common open override fun triggerChange ()","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/#properties","text":"Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher resolver [common] internal open override var resolver : Resolver","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/-co-auto-runner/","text":"// reactivestate / com.ensody.reactivestate / CoAutoRunner / CoAutoRunner CoAutoRunner \u00b6 [common] Content fun CoAutoRunner (launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >) More info Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables.","title":" co auto runner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/-co-auto-runner/#coautorunner","text":"[common] Content fun CoAutoRunner (launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >) More info","title":"CoAutoRunner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/-co-auto-runner/#parameters","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/attached-disposables/","text":"// reactivestate / com.ensody.reactivestate / CoAutoRunner / attachedDisposables attachedDisposables \u00b6 [common] Content open override val attachedDisposables : DisposableGroup More info The attached disposables which should be auto-disposed when this object is disposed.","title":"Attached disposables"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/attached-disposables/#attacheddisposables","text":"[common] Content open override val attachedDisposables : DisposableGroup More info The attached disposables which should be auto-disposed when this object is disposed.","title":"attachedDisposables"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/resolver/","text":"// reactivestate / com.ensody.reactivestate / CoAutoRunner / resolver resolver \u00b6 [common] Content internal open override var resolver : Resolver","title":"Resolver"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/resolver/#resolver","text":"[common] Content internal open override var resolver : Resolver","title":"resolver"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/run/","text":"// reactivestate / com.ensody.reactivestate / CoAutoRunner / run run \u00b6 [common] Content suspend fun run (): T More info Calls observer and tracks its dependencies.","title":"Run"},{"location":"reference/reactivestate/com.ensody.reactivestate/-co-auto-runner/run/#run","text":"[common] Content suspend fun run (): T More info Calls observer and tracks its dependencies.","title":"run"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/","text":"// reactivestate / com.ensody.reactivestate / CoroutineDispatcherConfig CoroutineDispatcherConfig \u00b6 [common] interface CoroutineDispatcherConfig Interface for a common set of CoroutineDispatchers. Properties \u00b6 Name Summary default [common] abstract val default : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Default. io [common] abstract val io : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers. main [common] abstract val main : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Main (i.e. unconfined [common] abstract val unconfined : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Unconfined. Inheritors \u00b6 Name DefaultCoroutineDispatcherConfig","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/#coroutinedispatcherconfig","text":"[common] interface CoroutineDispatcherConfig Interface for a common set of CoroutineDispatchers.","title":"CoroutineDispatcherConfig"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/#properties","text":"Name Summary default [common] abstract val default : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Default. io [common] abstract val io : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers. main [common] abstract val main : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Main (i.e. unconfined [common] abstract val unconfined : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/#inheritors","text":"Name DefaultCoroutineDispatcherConfig","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/default/","text":"// reactivestate / com.ensody.reactivestate / CoroutineDispatcherConfig / default default \u00b6 [common] Content abstract val default : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Default.","title":"Default"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/default/#default","text":"[common] Content abstract val default : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Default.","title":"default"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/io/","text":"// reactivestate / com.ensody.reactivestate / CoroutineDispatcherConfig / io io \u00b6 [common] Content abstract val io : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.IO.","title":"Io"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/io/#io","text":"[common] Content abstract val io : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.IO.","title":"io"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/main/","text":"// reactivestate / com.ensody.reactivestate / CoroutineDispatcherConfig / main main \u00b6 [common] Content abstract val main : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread).","title":"Main"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/main/#main","text":"[common] Content abstract val main : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread).","title":"main"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/unconfined/","text":"// reactivestate / com.ensody.reactivestate / CoroutineDispatcherConfig / unconfined unconfined \u00b6 [common] Content abstract val unconfined : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Unconfined"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-dispatcher-config/unconfined/#unconfined","text":"[common] Content abstract val unconfined : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"unconfined"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/","text":"// reactivestate / com.ensody.reactivestate / CoroutineLauncher CoroutineLauncher \u00b6 [common] interface CoroutineLauncher Interface for launching coroutines with error handling and loading state tracking. You can track multiple different kinds of loading states by defining separate MutableValueFlow . See also \u00b6 common com.ensody.reactivestate.ReactiveState for a full implementation that you\u2019ll usually want to use. Functions \u00b6 Name Summary launch Platforms: common abstract fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Properties \u00b6 Name Summary launcherScope [common] abstract val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int >The default loading tracker. Inheritors \u00b6 Name ReactiveState SimpleCoroutineLauncher Extensions \u00b6 Name Summary autoRun Platforms: common fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. coAutoRun Platforms: common fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. derived Platforms: common fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. Platforms: common fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion Platforms: common fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/#coroutinelauncher","text":"[common] interface CoroutineLauncher Interface for launching coroutines with error handling and loading state tracking. You can track multiple different kinds of loading states by defining separate MutableValueFlow .","title":"CoroutineLauncher"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/#see-also","text":"common com.ensody.reactivestate.ReactiveState for a full implementation that you\u2019ll usually want to use.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/#functions","text":"Name Summary launch Platforms: common abstract fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/#properties","text":"Name Summary launcherScope [common] abstract val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int >The default loading tracker.","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/#inheritors","text":"Name ReactiveState SimpleCoroutineLauncher","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/#extensions","text":"Name Summary autoRun Platforms: common fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. coAutoRun Platforms: common fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. derived Platforms: common fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. Platforms: common fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion Platforms: common fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Extensions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/launch/","text":"// reactivestate / com.ensody.reactivestate / CoroutineLauncher / launch launch \u00b6 [common] Content abstract fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job More info Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. Parameters \u00b6 common context additional to CoroutineScope.coroutineContext context of the coroutine. start coroutine start option. The default value is CoroutineStart.DEFAULT. withLoading Tracks loading state for the (re-)computation. Defaults to loading . This should be null for long-running / never-terminating coroutines (e.g. flow.collect). onError Optional custom error handler. block the coroutine code which will be invoked in the context of the provided scope.","title":"Launch"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/launch/#launch","text":"[common] Content abstract fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job More info Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state.","title":"launch"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/launch/#parameters","text":"common context additional to CoroutineScope.coroutineContext context of the coroutine. start coroutine start option. The default value is CoroutineStart.DEFAULT. withLoading Tracks loading state for the (re-)computation. Defaults to loading . This should be null for long-running / never-terminating coroutines (e.g. flow.collect). onError Optional custom error handler. block the coroutine code which will be invoked in the context of the provided scope.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/launcher-scope/","text":"// reactivestate / com.ensody.reactivestate / CoroutineLauncher / launcherScope launcherScope \u00b6 [common] Content abstract val launcherScope : CoroutineScope More info The underlying CoroutineScope of this launcher.","title":"Launcher scope"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/launcher-scope/#launcherscope","text":"[common] Content abstract val launcherScope : CoroutineScope More info The underlying CoroutineScope of this launcher.","title":"launcherScope"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/loading/","text":"// reactivestate / com.ensody.reactivestate / CoroutineLauncher / loading loading \u00b6 [common] Content abstract val loading : MutableValueFlow < Int > More info The default loading tracker. Use increment / decrement to safely update the loading counter.","title":"Loading"},{"location":"reference/reactivestate/com.ensody.reactivestate/-coroutine-launcher/loading/#loading","text":"[common] Content abstract val loading : MutableValueFlow < Int > More info The default loading tracker. Use increment / decrement to safely update the loading counter.","title":"loading"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/","text":"// reactivestate / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig DefaultCoroutineDispatcherConfig \u00b6 [common] object DefaultCoroutineDispatcherConfig : CoroutineDispatcherConfig The default CoroutineDispatcherConfig , mapping to Dispatchers. Properties \u00b6 Name Summary default [common] open override val default : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Default. io [common] open override val io : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers. main [common] open override val main : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Main (i.e. unconfined [common] open override val unconfined : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/#defaultcoroutinedispatcherconfig","text":"[common] object DefaultCoroutineDispatcherConfig : CoroutineDispatcherConfig The default CoroutineDispatcherConfig , mapping to Dispatchers.","title":"DefaultCoroutineDispatcherConfig"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/#properties","text":"Name Summary default [common] open override val default : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Default. io [common] open override val io : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers. main [common] open override val main : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Main (i.e. unconfined [common] open override val unconfined : CoroutineDispatcherA coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/default/","text":"// reactivestate / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig / default default \u00b6 [common] Content open override val default : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Default.","title":"Default"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/default/#default","text":"[common] Content open override val default : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Default.","title":"default"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/io/","text":"// reactivestate / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig / io io \u00b6 [common] Content open override val io : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.IO.","title":"Io"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/io/#io","text":"[common] Content open override val io : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.IO.","title":"io"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/main/","text":"// reactivestate / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig / main main \u00b6 [common] Content open override val main : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread).","title":"Main"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/main/#main","text":"[common] Content open override val main : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread).","title":"main"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/unconfined/","text":"// reactivestate / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig / unconfined unconfined \u00b6 [common] Content open override val unconfined : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Unconfined"},{"location":"reference/reactivestate/com.ensody.reactivestate/-default-coroutine-dispatcher-config/unconfined/#unconfined","text":"[common] Content open override val unconfined : CoroutineDispatcher More info A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"unconfined"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/","text":"// reactivestate / com.ensody.reactivestate / DisposableGroup DisposableGroup \u00b6 [common] interface DisposableGroup : DisposableHandle A Disposable that can dispose multiple Disposable and Job instances at once. On dispose this destroys all Disposable and Job instances attached to it. Functions \u00b6 Name Summary add Platforms: common abstract fun add (disposable: Disposable ) Add a Disposable to this group. Platforms: common abstract fun add (job: Job) Add a Job to this group. dispose Platforms: common abstract fun dispose () remove Platforms: common abstract fun remove (disposable: Disposable ) Remove a Disposable from this group. Platforms: common abstract fun remove (job: Job) Remove a Job from this group. Properties \u00b6 Name Summary size [common] abstract val size : Int Inheritors \u00b6 Name WhileUsedReferenceToken","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/#disposablegroup","text":"[common] interface DisposableGroup : DisposableHandle A Disposable that can dispose multiple Disposable and Job instances at once. On dispose this destroys all Disposable and Job instances attached to it.","title":"DisposableGroup"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/#functions","text":"Name Summary add Platforms: common abstract fun add (disposable: Disposable ) Add a Disposable to this group. Platforms: common abstract fun add (job: Job) Add a Job to this group. dispose Platforms: common abstract fun dispose () remove Platforms: common abstract fun remove (disposable: Disposable ) Remove a Disposable from this group. Platforms: common abstract fun remove (job: Job) Remove a Job from this group.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/#properties","text":"Name Summary size [common] abstract val size : Int","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/#inheritors","text":"Name WhileUsedReferenceToken","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/add/","text":"// reactivestate / com.ensody.reactivestate / DisposableGroup / add add \u00b6 [common] Content abstract fun add (disposable: Disposable ) More info Add a Disposable to this group. [common] Content abstract fun add (job: Job) More info Add a Job to this group.","title":"Add"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/add/#add","text":"[common] Content abstract fun add (disposable: Disposable ) More info Add a Disposable to this group. [common] Content abstract fun add (job: Job) More info Add a Job to this group.","title":"add"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/remove/","text":"// reactivestate / com.ensody.reactivestate / DisposableGroup / remove remove \u00b6 [common] Content abstract fun remove (disposable: Disposable ) More info Remove a Disposable from this group. [common] Content abstract fun remove (job: Job) More info Remove a Job from this group.","title":"Remove"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/remove/#remove","text":"[common] Content abstract fun remove (disposable: Disposable ) More info Remove a Disposable from this group. [common] Content abstract fun remove (job: Job) More info Remove a Job from this group.","title":"remove"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/size/","text":"// reactivestate / com.ensody.reactivestate / DisposableGroup / size size \u00b6 [common] Content abstract val size : Int","title":"Size"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-group/size/#size","text":"[common] Content abstract val size : Int","title":"size"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/","text":"// reactivestate / com.ensody.reactivestate / DisposableValue DisposableValue \u00b6 [common] class DisposableValue < T >( value : T , disposer : () -> Unit ) : DisposableHandle A value that must be explicitly dispose d when it\u2019s not needed anymore. Constructors \u00b6 DisposableValue [common] fun < T > DisposableValue (value: T , disposer: () -> Unit ) Functions \u00b6 Name Summary dispose Platforms: common open override fun dispose () Properties \u00b6 Name Summary value [common] val value : T","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/#disposablevalue","text":"[common] class DisposableValue < T >( value : T , disposer : () -> Unit ) : DisposableHandle A value that must be explicitly dispose d when it\u2019s not needed anymore.","title":"DisposableValue"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/#constructors","text":"DisposableValue [common] fun < T > DisposableValue (value: T , disposer: () -> Unit )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/#functions","text":"Name Summary dispose Platforms: common open override fun dispose ()","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/#properties","text":"Name Summary value [common] val value : T","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/-disposable-value/","text":"// reactivestate / com.ensody.reactivestate / DisposableValue / DisposableValue DisposableValue \u00b6 [common] Content fun < T > DisposableValue (value: T , disposer: () -> Unit )","title":" disposable value"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/-disposable-value/#disposablevalue","text":"[common] Content fun < T > DisposableValue (value: T , disposer: () -> Unit )","title":"DisposableValue"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/dispose/","text":"// reactivestate / com.ensody.reactivestate / DisposableValue / dispose dispose \u00b6 [common] Content open override fun dispose ()","title":"Dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/dispose/#dispose","text":"[common] Content open override fun dispose ()","title":"dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/value/","text":"// reactivestate / com.ensody.reactivestate / DisposableValue / value value \u00b6 [common] Content val value : T","title":"Value"},{"location":"reference/reactivestate/com.ensody.reactivestate/-disposable-value/value/#value","text":"[common] Content val value : T","title":"value"},{"location":"reference/reactivestate/com.ensody.reactivestate/-error-events/","text":"// reactivestate / com.ensody.reactivestate / ErrorEvents ErrorEvents \u00b6 [common] interface ErrorEvents Events interface with a simple onError event (e.g. for use with EventNotifier ). Functions \u00b6 Name Summary onError Platforms: common abstract fun onError (error: Throwable ) Triggers an error event.","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-error-events/#errorevents","text":"[common] interface ErrorEvents Events interface with a simple onError event (e.g. for use with EventNotifier ).","title":"ErrorEvents"},{"location":"reference/reactivestate/com.ensody.reactivestate/-error-events/#functions","text":"Name Summary onError Platforms: common abstract fun onError (error: Throwable ) Triggers an error event.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-error-events/on-error/","text":"// reactivestate / com.ensody.reactivestate / ErrorEvents / onError onError \u00b6 [common] Content abstract fun onError (error: Throwable ) More info Triggers an error event.","title":"On error"},{"location":"reference/reactivestate/com.ensody.reactivestate/-error-events/on-error/#onerror","text":"[common] Content abstract fun onError (error: Throwable ) More info Triggers an error event.","title":"onError"},{"location":"reference/reactivestate/com.ensody.reactivestate/-event-notifier/","text":"// reactivestate / com.ensody.reactivestate / EventNotifier EventNotifier \u00b6 [common] interface EventNotifier < T > : MutableFlow T .() -> Unit > This is used to send events to an observer. All events are queued for later processing. The possible events are defined as method calls on an interface T . This allows for easy composition of multiple events. One of the most common events interfaces is ErrorEvents . See also \u00b6 common com.ensody.reactivestate.ReactiveState for more advanced usage of this pattern. Example: interface MyHandlerEvents : ErrorEvents, OtherEvents { fun onSomethingHappened() } class MyHandler { val eventNotifier = EventNotifier () fun doSomething() { withErrorReporting(eventNotifier) { if (computeResult() 5) { eventNotifier { onSomethingHappened() } } else { eventNotifier { onOtherEvent() } } } } } Functions \u00b6 Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector T .() -> Unit >) emit Platforms: common abstract suspend fun emit (value: suspend T .() -> Unit ) invoke Platforms: common abstract operator fun invoke (block: suspend T .() -> Unit ) Adds a lambda function to the event stream. tryEmit Platforms: common abstract fun tryEmit (value: suspend T .() -> Unit ): Boolean Adds a value to this Flow if there\u2019s still capacity left. Extensions \u00b6 Name Summary handleEvents Platforms: android fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T , owner: LifecycleOwner ) Consumes and handles EventNotifier \u2018s events on the given handler , but only when owner is in >=STARTED state. Platforms: common suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler .","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-event-notifier/#eventnotifier","text":"[common] interface EventNotifier < T > : MutableFlow T .() -> Unit > This is used to send events to an observer. All events are queued for later processing. The possible events are defined as method calls on an interface T . This allows for easy composition of multiple events. One of the most common events interfaces is ErrorEvents .","title":"EventNotifier"},{"location":"reference/reactivestate/com.ensody.reactivestate/-event-notifier/#see-also","text":"common com.ensody.reactivestate.ReactiveState for more advanced usage of this pattern. Example: interface MyHandlerEvents : ErrorEvents, OtherEvents { fun onSomethingHappened() } class MyHandler { val eventNotifier = EventNotifier () fun doSomething() { withErrorReporting(eventNotifier) { if (computeResult() 5) { eventNotifier { onSomethingHappened() } } else { eventNotifier { onOtherEvent() } } } } }","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate/-event-notifier/#functions","text":"Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector T .() -> Unit >) emit Platforms: common abstract suspend fun emit (value: suspend T .() -> Unit ) invoke Platforms: common abstract operator fun invoke (block: suspend T .() -> Unit ) Adds a lambda function to the event stream. tryEmit Platforms: common abstract fun tryEmit (value: suspend T .() -> Unit ): Boolean Adds a value to this Flow if there\u2019s still capacity left.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-event-notifier/#extensions","text":"Name Summary handleEvents Platforms: android fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T , owner: LifecycleOwner ) Consumes and handles EventNotifier \u2018s events on the given handler , but only when owner is in >=STARTED state. Platforms: common suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler .","title":"Extensions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-event-notifier/invoke/","text":"// reactivestate / com.ensody.reactivestate / EventNotifier / invoke invoke \u00b6 [common] Content abstract operator fun invoke (block: suspend T .() -> Unit ) More info Adds a lambda function to the event stream.","title":"Invoke"},{"location":"reference/reactivestate/com.ensody.reactivestate/-event-notifier/invoke/#invoke","text":"[common] Content abstract operator fun invoke (block: suspend T .() -> Unit ) More info Adds a lambda function to the event stream.","title":"invoke"},{"location":"reference/reactivestate/com.ensody.reactivestate/-experimental-reactive-state-api/","text":"// reactivestate / com.ensody.reactivestate / ExperimentalReactiveStateApi ExperimentalReactiveStateApi \u00b6 [common] annotation class ExperimentalReactiveStateApi This feature is not stable yet and can introduce breaking API changes in minor releases. Constructors \u00b6 ExperimentalReactiveStateApi [common] fun ExperimentalReactiveStateApi ()","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-experimental-reactive-state-api/#experimentalreactivestateapi","text":"[common] annotation class ExperimentalReactiveStateApi This feature is not stable yet and can introduce breaking API changes in minor releases.","title":"ExperimentalReactiveStateApi"},{"location":"reference/reactivestate/com.ensody.reactivestate/-experimental-reactive-state-api/#constructors","text":"ExperimentalReactiveStateApi [common] fun ExperimentalReactiveStateApi ()","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-experimental-reactive-state-api/-experimental-reactive-state-api/","text":"// reactivestate / com.ensody.reactivestate / ExperimentalReactiveStateApi / ExperimentalReactiveStateApi ExperimentalReactiveStateApi \u00b6 [common] Content fun ExperimentalReactiveStateApi ()","title":" experimental reactive state api"},{"location":"reference/reactivestate/com.ensody.reactivestate/-experimental-reactive-state-api/-experimental-reactive-state-api/#experimentalreactivestateapi","text":"[common] Content fun ExperimentalReactiveStateApi ()","title":"ExperimentalReactiveStateApi"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/","text":"// reactivestate / com.ensody.reactivestate / InMemoryStateFlowStore InMemoryStateFlowStore \u00b6 [common] class InMemoryStateFlowStore : StateFlowStore A StateFlowStore that can be used for unit tests or non-Android parts of multiplatform projects. Constructors \u00b6 InMemoryStateFlowStore [common] fun InMemoryStateFlowStore () Functions \u00b6 Name Summary contains Platforms: common open operator override fun contains (key: String ): Boolean getData Platforms: common open override fun < T > getData (key: String , default: T ): MutableValueFlow < T > fun < T > getData (key: String , default: T , setter: ( T ) -> Unit ?): MutableValueFlow < T >","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/#inmemorystateflowstore","text":"[common] class InMemoryStateFlowStore : StateFlowStore A StateFlowStore that can be used for unit tests or non-Android parts of multiplatform projects.","title":"InMemoryStateFlowStore"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/#constructors","text":"InMemoryStateFlowStore [common] fun InMemoryStateFlowStore ()","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/#functions","text":"Name Summary contains Platforms: common open operator override fun contains (key: String ): Boolean getData Platforms: common open override fun < T > getData (key: String , default: T ): MutableValueFlow < T > fun < T > getData (key: String , default: T , setter: ( T ) -> Unit ?): MutableValueFlow < T >","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/-in-memory-state-flow-store/","text":"// reactivestate / com.ensody.reactivestate / InMemoryStateFlowStore / InMemoryStateFlowStore InMemoryStateFlowStore \u00b6 [common] Content fun InMemoryStateFlowStore ()","title":" in memory state flow store"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/-in-memory-state-flow-store/#inmemorystateflowstore","text":"[common] Content fun InMemoryStateFlowStore ()","title":"InMemoryStateFlowStore"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/contains/","text":"// reactivestate / com.ensody.reactivestate / InMemoryStateFlowStore / contains contains \u00b6 [common] Content open operator override fun contains (key: String ): Boolean","title":"Contains"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/contains/#contains","text":"[common] Content open operator override fun contains (key: String ): Boolean","title":"contains"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/get-data/","text":"// reactivestate / com.ensody.reactivestate / InMemoryStateFlowStore / getData getData \u00b6 [common] Content open override fun < T > getData (key: String , default: T ): MutableValueFlow < T > fun < T > getData (key: String , default: T , setter: ( T ) -> Unit ?): MutableValueFlow < T >","title":"Get data"},{"location":"reference/reactivestate/com.ensody.reactivestate/-in-memory-state-flow-store/get-data/#getdata","text":"[common] Content open override fun < T > getData (key: String , default: T ): MutableValueFlow < T > fun < T > getData (key: String , default: T , setter: ( T ) -> Unit ?): MutableValueFlow < T >","title":"getData"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/","text":"// reactivestate / com.ensody.reactivestate / InternalBaseAutoRunner InternalBaseAutoRunner \u00b6 [common] abstract class InternalBaseAutoRunner ( launcher : CoroutineLauncher , flowTransformer : AutoRunFlowTransformer ) : BaseAutoRunner Functions \u00b6 Name Summary dispose Platforms: common open override fun dispose () Stops watching observables. triggerChange Platforms: common open override fun triggerChange () Properties \u00b6 Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher resolver [common] internal open override var resolver : Resolver Inheritors \u00b6 Name AutoRunner CoAutoRunner","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/#internalbaseautorunner","text":"[common] abstract class InternalBaseAutoRunner ( launcher : CoroutineLauncher , flowTransformer : AutoRunFlowTransformer ) : BaseAutoRunner","title":"InternalBaseAutoRunner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/#functions","text":"Name Summary dispose Platforms: common open override fun dispose () Stops watching observables. triggerChange Platforms: common open override fun triggerChange ()","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/#properties","text":"Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher resolver [common] internal open override var resolver : Resolver","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/#inheritors","text":"Name AutoRunner CoAutoRunner","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/-internal-base-auto-runner/","text":"// reactivestate / com.ensody.reactivestate / InternalBaseAutoRunner / InternalBaseAutoRunner InternalBaseAutoRunner \u00b6 [common] Content fun InternalBaseAutoRunner (launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer )","title":" internal base auto runner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/-internal-base-auto-runner/#internalbaseautorunner","text":"[common] Content fun InternalBaseAutoRunner (launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer )","title":"InternalBaseAutoRunner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/attached-disposables/","text":"// reactivestate / com.ensody.reactivestate / InternalBaseAutoRunner / attachedDisposables attachedDisposables \u00b6 [common] Content open override val attachedDisposables : DisposableGroup More info The attached disposables which should be auto-disposed when this object is disposed.","title":"Attached disposables"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/attached-disposables/#attacheddisposables","text":"[common] Content open override val attachedDisposables : DisposableGroup More info The attached disposables which should be auto-disposed when this object is disposed.","title":"attachedDisposables"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/dispose/","text":"// reactivestate / com.ensody.reactivestate / InternalBaseAutoRunner / dispose dispose \u00b6 [common] Content open override fun dispose () More info Stops watching observables.","title":"Dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/dispose/#dispose","text":"[common] Content open override fun dispose () More info Stops watching observables.","title":"dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/launcher/","text":"// reactivestate / com.ensody.reactivestate / InternalBaseAutoRunner / launcher launcher \u00b6 [common] Content override val launcher : CoroutineLauncher","title":"Launcher"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/launcher/#launcher","text":"[common] Content override val launcher : CoroutineLauncher","title":"launcher"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/resolver/","text":"// reactivestate / com.ensody.reactivestate / InternalBaseAutoRunner / resolver resolver \u00b6 [common] Content internal open override var resolver : Resolver","title":"Resolver"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/resolver/#resolver","text":"[common] Content internal open override var resolver : Resolver","title":"resolver"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/trigger-change/","text":"// reactivestate / com.ensody.reactivestate / InternalBaseAutoRunner / triggerChange triggerChange \u00b6 [common] Content open override fun triggerChange ()","title":"Trigger change"},{"location":"reference/reactivestate/com.ensody.reactivestate/-internal-base-auto-runner/trigger-change/#triggerchange","text":"[common] Content open override fun triggerChange ()","title":"triggerChange"},{"location":"reference/reactivestate/com.ensody.reactivestate/-job-disposable/","text":"// reactivestate / com.ensody.reactivestate / JobDisposable JobDisposable \u00b6 [common] class JobDisposable ( job : Job) : DisposableHandle A Disposable wrapping a Job. Constructors \u00b6 JobDisposable [common] fun JobDisposable (job: Job) Functions \u00b6 Name Summary dispose Platforms: common open override fun dispose ()","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-job-disposable/#jobdisposable","text":"[common] class JobDisposable ( job : Job) : DisposableHandle A Disposable wrapping a Job.","title":"JobDisposable"},{"location":"reference/reactivestate/com.ensody.reactivestate/-job-disposable/#constructors","text":"JobDisposable [common] fun JobDisposable (job: Job)","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-job-disposable/#functions","text":"Name Summary dispose Platforms: common open override fun dispose ()","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-job-disposable/-job-disposable/","text":"// reactivestate / com.ensody.reactivestate / JobDisposable / JobDisposable JobDisposable \u00b6 [common] Content fun JobDisposable (job: Job)","title":" job disposable"},{"location":"reference/reactivestate/com.ensody.reactivestate/-job-disposable/-job-disposable/#jobdisposable","text":"[common] Content fun JobDisposable (job: Job)","title":"JobDisposable"},{"location":"reference/reactivestate/com.ensody.reactivestate/-job-disposable/dispose/","text":"// reactivestate / com.ensody.reactivestate / JobDisposable / dispose dispose \u00b6 [common] Content open override fun dispose ()","title":"Dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-job-disposable/dispose/#dispose","text":"[common] Content open override fun dispose ()","title":"dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-flow/","text":"// reactivestate / com.ensody.reactivestate / MutableFlow MutableFlow \u00b6 [common] interface MutableFlow < T > : Flow< T > , FlowCollector< T > A Flow where you can emit/ tryEmit values into (backed by a Channel). Functions \u00b6 Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector< T >) emit Platforms: common abstract suspend fun emit (value: T ) tryEmit Platforms: common abstract fun tryEmit (value: T ): Boolean Adds a value to this Flow if there\u2019s still capacity left. Inheritors \u00b6 Name EventNotifier","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-flow/#mutableflow","text":"[common] interface MutableFlow < T > : Flow< T > , FlowCollector< T > A Flow where you can emit/ tryEmit values into (backed by a Channel).","title":"MutableFlow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-flow/#functions","text":"Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector< T >) emit Platforms: common abstract suspend fun emit (value: T ) tryEmit Platforms: common abstract fun tryEmit (value: T ): Boolean Adds a value to this Flow if there\u2019s still capacity left.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-flow/#inheritors","text":"Name EventNotifier","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-flow/try-emit/","text":"// reactivestate / com.ensody.reactivestate / MutableFlow / tryEmit tryEmit \u00b6 [common] Content abstract fun tryEmit (value: T ): Boolean More info Adds a value to this Flow if there\u2019s still capacity left.","title":"Try emit"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-flow/try-emit/#tryemit","text":"[common] Content abstract fun tryEmit (value: T ): Boolean More info Adds a value to this Flow if there\u2019s still capacity left.","title":"tryEmit"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/","text":"// reactivestate / com.ensody.reactivestate / MutableValueFlow MutableValueFlow \u00b6 [common] interface MutableValueFlow < T > : ValueFlow < T > , MutableStateFlow< T > A version of MutableStateFlow that provides better support for mutable values via the update operation. Assigning to .value still has distinctUntilChanged behavior, but emit/tryEmit and update always trigger a change event. Example of mutating the value in-place: flow.update { it.subvalue1.deepsubvalue.somevalue += 3 it.subvalue2.state = SomeState.IN_PROGRESS it.isLoading = true } Why is this needed? In Kotlin, working with nested immutable values (e.g. nested data class with val) is very unwieldy because you have to manually copy each element and its children: flow.value = flow.value.let { it.copy( subvalue1 = it.subvalue1.copy( deepsubvalue = it.subvalue1.deepsubvalue.copy(somevalue = it.subvalue1.deepsubvalue.somevalue + 3) ), subvalue2 = it.subvalue2.copy(state = SomeState.IN_PROGRESS), isLoading = true, ) } In many cases the UI state is even held in mutable data classes (with var), but doing the following would be unsafe with MutableStateFlow because the value is considered unchanged, so this code won\u2019t trigger a UI update: flow.value = flow.value.also { it.subvalue1.deepsubvalue.somevalue += 3 it.subvalue2.state = SomeState.IN_PROGRESS it.isLoading = true } Kotlin just isn\u2019t a pure functional language with built-in lens support and we have to deal with mutable values, so we should prevent overly complicated code with nested copy() and stupid mistakes like missing UI updates. That\u2019s why MutableValueFlow tries to make working with mutable values easy and safe. Functions \u00b6 Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector< T >) compareAndSet Platforms: common abstract fun compareAndSet (expect: T , update: T ): Boolean emit Platforms: common abstract suspend override fun emit (value: T ) replaceLocked Platforms: common abstract fun replaceLocked (block: T .() -> T ): T Replaces the value with block \u2018s return value. resetReplayCache Platforms: common abstract fun resetReplayCache () tryEmit Platforms: common abstract fun tryEmit (value: T ): Boolean update Platforms: common abstract fun update (block: ( T ) -> Unit ) Mutates value in-place and notifies listeners. updateThis Platforms: common open fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. Properties \u00b6 Name Summary replayCache [common] abstract val replayCache : List < T > subscriptionCount [common] abstract val subscriptionCount : StateFlow< Int > value [common] abstract val value : T Extensions \u00b6 Name Summary decrement Platforms: common fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount . increment Platforms: common fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount . incrementFrom Platforms: common suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow .","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/#mutablevalueflow","text":"[common] interface MutableValueFlow < T > : ValueFlow < T > , MutableStateFlow< T > A version of MutableStateFlow that provides better support for mutable values via the update operation. Assigning to .value still has distinctUntilChanged behavior, but emit/tryEmit and update always trigger a change event. Example of mutating the value in-place: flow.update { it.subvalue1.deepsubvalue.somevalue += 3 it.subvalue2.state = SomeState.IN_PROGRESS it.isLoading = true } Why is this needed? In Kotlin, working with nested immutable values (e.g. nested data class with val) is very unwieldy because you have to manually copy each element and its children: flow.value = flow.value.let { it.copy( subvalue1 = it.subvalue1.copy( deepsubvalue = it.subvalue1.deepsubvalue.copy(somevalue = it.subvalue1.deepsubvalue.somevalue + 3) ), subvalue2 = it.subvalue2.copy(state = SomeState.IN_PROGRESS), isLoading = true, ) } In many cases the UI state is even held in mutable data classes (with var), but doing the following would be unsafe with MutableStateFlow because the value is considered unchanged, so this code won\u2019t trigger a UI update: flow.value = flow.value.also { it.subvalue1.deepsubvalue.somevalue += 3 it.subvalue2.state = SomeState.IN_PROGRESS it.isLoading = true } Kotlin just isn\u2019t a pure functional language with built-in lens support and we have to deal with mutable values, so we should prevent overly complicated code with nested copy() and stupid mistakes like missing UI updates. That\u2019s why MutableValueFlow tries to make working with mutable values easy and safe.","title":"MutableValueFlow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/#functions","text":"Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector< T >) compareAndSet Platforms: common abstract fun compareAndSet (expect: T , update: T ): Boolean emit Platforms: common abstract suspend override fun emit (value: T ) replaceLocked Platforms: common abstract fun replaceLocked (block: T .() -> T ): T Replaces the value with block \u2018s return value. resetReplayCache Platforms: common abstract fun resetReplayCache () tryEmit Platforms: common abstract fun tryEmit (value: T ): Boolean update Platforms: common abstract fun update (block: ( T ) -> Unit ) Mutates value in-place and notifies listeners. updateThis Platforms: common open fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/#properties","text":"Name Summary replayCache [common] abstract val replayCache : List < T > subscriptionCount [common] abstract val subscriptionCount : StateFlow< Int > value [common] abstract val value : T","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/#extensions","text":"Name Summary decrement Platforms: common fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount . increment Platforms: common fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount . incrementFrom Platforms: common suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow .","title":"Extensions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/replace-locked/","text":"// reactivestate / com.ensody.reactivestate / MutableValueFlow / replaceLocked replaceLocked \u00b6 [common] Content abstract fun replaceLocked (block: T .() -> T ): T More info Replaces the value with block \u2018s return value. This is safe under concurrency. This is a simple helper for the common case where you want to copy() a data class: data class Foo(val num: Int) val stateFlow = MutableStateFlow(Foo(3)) stateFlow.replace { copy(num = 5) } Return \u00b6 The previous value before replacing. See also \u00b6 common increment and decrement for functions optimized for Int operations.","title":"Replace locked"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/replace-locked/#replacelocked","text":"[common] Content abstract fun replaceLocked (block: T .() -> T ): T More info Replaces the value with block \u2018s return value. This is safe under concurrency. This is a simple helper for the common case where you want to copy() a data class: data class Foo(val num: Int) val stateFlow = MutableStateFlow(Foo(3)) stateFlow.replace { copy(num = 5) }","title":"replaceLocked"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/replace-locked/#return","text":"The previous value before replacing.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/replace-locked/#see-also","text":"common increment and decrement for functions optimized for Int operations.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/update-this/","text":"// reactivestate / com.ensody.reactivestate / MutableValueFlow / updateThis updateThis \u00b6 [common] Content open fun updateThis (block: T .() -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed via this.","title":"Update this"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/update-this/#updatethis","text":"[common] Content open fun updateThis (block: T .() -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed via this.","title":"updateThis"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/update/","text":"// reactivestate / com.ensody.reactivestate / MutableValueFlow / update update \u00b6 [common] Content abstract fun update (block: ( T ) -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"Update"},{"location":"reference/reactivestate/com.ensody.reactivestate/-mutable-value-flow/update/#update","text":"[common] Content abstract fun update (block: ( T ) -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"update"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/","text":"// reactivestate / com.ensody.reactivestate / NamespacedStateFlowStore NamespacedStateFlowStore \u00b6 [common] class NamespacedStateFlowStore ( store : StateFlowStore , namespace : String ) : StateFlowStore A wrapper StateFlowStore that prefixes every key with a namespace. This is useful for preventing name clashes when passing StateFlowStore s to sub-components. Constructors \u00b6 NamespacedStateFlowStore [common] fun NamespacedStateFlowStore (store: StateFlowStore , namespace: String ) Functions \u00b6 Name Summary contains Platforms: common open operator override fun contains (key: String ): Boolean getData Platforms: common open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/#namespacedstateflowstore","text":"[common] class NamespacedStateFlowStore ( store : StateFlowStore , namespace : String ) : StateFlowStore A wrapper StateFlowStore that prefixes every key with a namespace. This is useful for preventing name clashes when passing StateFlowStore s to sub-components.","title":"NamespacedStateFlowStore"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/#constructors","text":"NamespacedStateFlowStore [common] fun NamespacedStateFlowStore (store: StateFlowStore , namespace: String )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/#functions","text":"Name Summary contains Platforms: common open operator override fun contains (key: String ): Boolean getData Platforms: common open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/-namespaced-state-flow-store/","text":"// reactivestate / com.ensody.reactivestate / NamespacedStateFlowStore / NamespacedStateFlowStore NamespacedStateFlowStore \u00b6 [common] Content fun NamespacedStateFlowStore (store: StateFlowStore , namespace: String )","title":" namespaced state flow store"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/-namespaced-state-flow-store/#namespacedstateflowstore","text":"[common] Content fun NamespacedStateFlowStore (store: StateFlowStore , namespace: String )","title":"NamespacedStateFlowStore"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/contains/","text":"// reactivestate / com.ensody.reactivestate / NamespacedStateFlowStore / contains contains \u00b6 [common] Content open operator override fun contains (key: String ): Boolean","title":"Contains"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/contains/#contains","text":"[common] Content open operator override fun contains (key: String ): Boolean","title":"contains"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/get-data/","text":"// reactivestate / com.ensody.reactivestate / NamespacedStateFlowStore / getData getData \u00b6 [common] Content open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Get data"},{"location":"reference/reactivestate/com.ensody.reactivestate/-namespaced-state-flow-store/get-data/#getdata","text":"[common] Content open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"getData"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-dispose/","text":"// reactivestate / com.ensody.reactivestate / OnDispose OnDispose \u00b6 [common] class OnDispose ( function : () -> Unit ) : DisposableHandle A Disposable executing the given function on dispose(). Example: val disposable = OnDispose { println(\u201cdisposing myself\u201d) } disposable.dispose() // => \u201cdisposing myself\u201d Constructors \u00b6 OnDispose [common] fun OnDispose (function: () -> Unit ) Functions \u00b6 Name Summary dispose Platforms: common open override fun dispose ()","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-dispose/#ondispose","text":"[common] class OnDispose ( function : () -> Unit ) : DisposableHandle A Disposable executing the given function on dispose(). Example: val disposable = OnDispose { println(\u201cdisposing myself\u201d) } disposable.dispose() // => \u201cdisposing myself\u201d","title":"OnDispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-dispose/#constructors","text":"OnDispose [common] fun OnDispose (function: () -> Unit )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-dispose/#functions","text":"Name Summary dispose Platforms: common open override fun dispose ()","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-dispose/-on-dispose/","text":"// reactivestate / com.ensody.reactivestate / OnDispose / OnDispose OnDispose \u00b6 [common] Content fun OnDispose (function: () -> Unit )","title":" on dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-dispose/-on-dispose/#ondispose","text":"[common] Content fun OnDispose (function: () -> Unit )","title":"OnDispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-dispose/dispose/","text":"// reactivestate / com.ensody.reactivestate / OnDispose / dispose dispose \u00b6 [common] Content open override fun dispose ()","title":"Dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-dispose/dispose/#dispose","text":"[common] Content open override fun dispose ()","title":"dispose"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-reactive-state-attached/","text":"// reactivestate / com.ensody.reactivestate / OnReactiveStateAttached OnReactiveStateAttached \u00b6 [common] interface OnReactiveStateAttached Implement this interface to get notified of every ReactiveState added to your object. This can be useful e.g. to map ReactiveState.loading to a setLoading(isLoading: Boolean) method in every UI screen (e.g. on Android you could have a BaseFragment implementing this interface). Functions \u00b6 Name Summary onReactiveStateAttached Platforms: common abstract fun onReactiveStateAttached (reactiveState: ReactiveState ErrorEvents >)","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-reactive-state-attached/#onreactivestateattached","text":"[common] interface OnReactiveStateAttached Implement this interface to get notified of every ReactiveState added to your object. This can be useful e.g. to map ReactiveState.loading to a setLoading(isLoading: Boolean) method in every UI screen (e.g. on Android you could have a BaseFragment implementing this interface).","title":"OnReactiveStateAttached"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-reactive-state-attached/#functions","text":"Name Summary onReactiveStateAttached Platforms: common abstract fun onReactiveStateAttached (reactiveState: ReactiveState ErrorEvents >)","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-reactive-state-attached/on-reactive-state-attached/","text":"// reactivestate / com.ensody.reactivestate / OnReactiveStateAttached / onReactiveStateAttached onReactiveStateAttached \u00b6 [common] Content abstract fun onReactiveStateAttached (reactiveState: ReactiveState ErrorEvents >)","title":"On reactive state attached"},{"location":"reference/reactivestate/com.ensody.reactivestate/-on-reactive-state-attached/on-reactive-state-attached/#onreactivestateattached","text":"[common] Content abstract fun onReactiveStateAttached (reactiveState: ReactiveState ErrorEvents >)","title":"onReactiveStateAttached"},{"location":"reference/reactivestate/com.ensody.reactivestate/-reactive-state/","text":"// reactivestate / com.ensody.reactivestate / ReactiveState ReactiveState \u00b6 [common] interface ReactiveState < E : ErrorEvents > : CoroutineLauncher An interface for ViewModels and any other objects that can trigger one-time events/actions and handle errors. Make sure you always launch coroutines via launch (instead of the scope) to get automatic error handling. See also \u00b6 common com.ensody.reactivestate.BaseReactiveState for a ready-made base class (or delegate). Functions \u00b6 Name Summary launch Platforms: common abstract fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Properties \u00b6 Name Summary eventNotifier [common] abstract val eventNotifier : EventNotifier < E > launcherScope [common] abstract val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int >The default loading tracker. Inheritors \u00b6 Name BaseReactiveState","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-reactive-state/#reactivestate","text":"[common] interface ReactiveState < E : ErrorEvents > : CoroutineLauncher An interface for ViewModels and any other objects that can trigger one-time events/actions and handle errors. Make sure you always launch coroutines via launch (instead of the scope) to get automatic error handling.","title":"ReactiveState"},{"location":"reference/reactivestate/com.ensody.reactivestate/-reactive-state/#see-also","text":"common com.ensody.reactivestate.BaseReactiveState for a ready-made base class (or delegate).","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate/-reactive-state/#functions","text":"Name Summary launch Platforms: common abstract fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-reactive-state/#properties","text":"Name Summary eventNotifier [common] abstract val eventNotifier : EventNotifier < E > launcherScope [common] abstract val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int >The default loading tracker.","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-reactive-state/#inheritors","text":"Name BaseReactiveState","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-reactive-state/event-notifier/","text":"// reactivestate / com.ensody.reactivestate / ReactiveState / eventNotifier eventNotifier \u00b6 [common] Content abstract val eventNotifier : EventNotifier < E >","title":"Event notifier"},{"location":"reference/reactivestate/com.ensody.reactivestate/-reactive-state/event-notifier/#eventnotifier","text":"[common] Content abstract val eventNotifier : EventNotifier < E >","title":"eventNotifier"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/","text":"// reactivestate / com.ensody.reactivestate / Resolver Resolver \u00b6 [common] class Resolver ( autoRunner : BaseAutoRunner ) Tracks observables for AutoRunner and CoAutoRunner . Constructors \u00b6 Resolver [common] fun Resolver (autoRunner: BaseAutoRunner ) Functions \u00b6 Name Summary track Platforms: common fun < S : Any , T : AutoRunnerObservable > track (underlyingObservable: S , getObservable: () -> T ): T Tracks an arbitrary observable. Properties \u00b6 Name Summary autoRunner [common] val autoRunner : BaseAutoRunner Extensions \u00b6 Name Summary get Platforms: common fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope). Platforms: common fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used. Platforms: android fun < T > Resolver . get (data: LiveData < T >): T ? Returns LiveData.getValue and tracks the observable.","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/#resolver","text":"[common] class Resolver ( autoRunner : BaseAutoRunner ) Tracks observables for AutoRunner and CoAutoRunner .","title":"Resolver"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/#constructors","text":"Resolver [common] fun Resolver (autoRunner: BaseAutoRunner )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/#functions","text":"Name Summary track Platforms: common fun < S : Any , T : AutoRunnerObservable > track (underlyingObservable: S , getObservable: () -> T ): T Tracks an arbitrary observable.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/#properties","text":"Name Summary autoRunner [common] val autoRunner : BaseAutoRunner","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/#extensions","text":"Name Summary get Platforms: common fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope). Platforms: common fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used. Platforms: android fun < T > Resolver . get (data: LiveData < T >): T ? Returns LiveData.getValue and tracks the observable.","title":"Extensions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/-resolver/","text":"// reactivestate / com.ensody.reactivestate / Resolver / Resolver Resolver \u00b6 [common] Content fun Resolver (autoRunner: BaseAutoRunner )","title":" resolver"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/-resolver/#resolver","text":"[common] Content fun Resolver (autoRunner: BaseAutoRunner )","title":"Resolver"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/auto-runner/","text":"// reactivestate / com.ensody.reactivestate / Resolver / autoRunner autoRunner \u00b6 [common] Content val autoRunner : BaseAutoRunner","title":"Auto runner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/auto-runner/#autorunner","text":"[common] Content val autoRunner : BaseAutoRunner","title":"autoRunner"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/track/","text":"// reactivestate / com.ensody.reactivestate / Resolver / track track \u00b6 [common] Content fun < S : Any , T : AutoRunnerObservable > track (underlyingObservable: S , getObservable: () -> T ): T More info Tracks an arbitrary observable. This creates a new AutoRunnerObservable if one doesn\u2019t already exist for the underlyingObservable . Otherwise it reuses the existing AutoRunnerObservable . Return \u00b6 The instantiated AutoRunnerObservable of type T . Parameters \u00b6 common underlyingObservable The raw, underlying observable (e.g. Android\u2019s LiveData). getObservable Used to create an AutoRunnerObservable wrapper around underlyingObservable .","title":"Track"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/track/#track","text":"[common] Content fun < S : Any , T : AutoRunnerObservable > track (underlyingObservable: S , getObservable: () -> T ): T More info Tracks an arbitrary observable. This creates a new AutoRunnerObservable if one doesn\u2019t already exist for the underlyingObservable . Otherwise it reuses the existing AutoRunnerObservable .","title":"track"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/track/#return","text":"The instantiated AutoRunnerObservable of type T .","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate/-resolver/track/#parameters","text":"common underlyingObservable The raw, underlying observable (e.g. Android\u2019s LiveData). getObservable Used to create an AutoRunnerObservable wrapper around underlyingObservable .","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/","text":"// reactivestate / com.ensody.reactivestate / SimpleCoroutineLauncher SimpleCoroutineLauncher \u00b6 [common] open class SimpleCoroutineLauncher ( launcherScope : CoroutineScope) : CoroutineLauncher Simple default implementation of a CoroutineLauncher which uses a given CoroutineScope. Usually you\u2019ll want to use a ReactiveState which also does error handling. Constructors \u00b6 SimpleCoroutineLauncher [common] fun SimpleCoroutineLauncher (launcherScope: CoroutineScope) Functions \u00b6 Name Summary launch Platforms: common open override fun launch (context: CoroutineContext , start: CoroutineStart, withLoading: MutableValueFlow < Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. onError Platforms: common open fun onError (error: Throwable ) Properties \u00b6 Name Summary launcherScope [common] override val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [common] override val loading : MutableValueFlow < Int >The default loading tracker. Inheritors \u00b6 Name LifecycleCoroutineLauncher BaseReactiveState","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/#simplecoroutinelauncher","text":"[common] open class SimpleCoroutineLauncher ( launcherScope : CoroutineScope) : CoroutineLauncher Simple default implementation of a CoroutineLauncher which uses a given CoroutineScope. Usually you\u2019ll want to use a ReactiveState which also does error handling.","title":"SimpleCoroutineLauncher"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/#constructors","text":"SimpleCoroutineLauncher [common] fun SimpleCoroutineLauncher (launcherScope: CoroutineScope)","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/#functions","text":"Name Summary launch Platforms: common open override fun launch (context: CoroutineContext , start: CoroutineStart, withLoading: MutableValueFlow < Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. onError Platforms: common open fun onError (error: Throwable )","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/#properties","text":"Name Summary launcherScope [common] override val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [common] override val loading : MutableValueFlow < Int >The default loading tracker.","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/#inheritors","text":"Name LifecycleCoroutineLauncher BaseReactiveState","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/-simple-coroutine-launcher/","text":"// reactivestate / com.ensody.reactivestate / SimpleCoroutineLauncher / SimpleCoroutineLauncher SimpleCoroutineLauncher \u00b6 [common] Content fun SimpleCoroutineLauncher (launcherScope: CoroutineScope)","title":" simple coroutine launcher"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/-simple-coroutine-launcher/#simplecoroutinelauncher","text":"[common] Content fun SimpleCoroutineLauncher (launcherScope: CoroutineScope)","title":"SimpleCoroutineLauncher"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/launch/","text":"// reactivestate / com.ensody.reactivestate / SimpleCoroutineLauncher / launch launch \u00b6 [common] Content open override fun launch (context: CoroutineContext , start: CoroutineStart, withLoading: MutableValueFlow < Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend CoroutineScope.() -> Unit ): Job More info Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. Parameters \u00b6 common context additional to CoroutineScope.coroutineContext context of the coroutine. start coroutine start option. The default value is CoroutineStart.DEFAULT. withLoading Tracks loading state for the (re-)computation. Defaults to loading . This should be null for long-running / never-terminating coroutines (e.g. flow.collect). onError Optional custom error handler. block the coroutine code which will be invoked in the context of the provided scope.","title":"Launch"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/launch/#launch","text":"[common] Content open override fun launch (context: CoroutineContext , start: CoroutineStart, withLoading: MutableValueFlow < Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend CoroutineScope.() -> Unit ): Job More info Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state.","title":"launch"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/launch/#parameters","text":"common context additional to CoroutineScope.coroutineContext context of the coroutine. start coroutine start option. The default value is CoroutineStart.DEFAULT. withLoading Tracks loading state for the (re-)computation. Defaults to loading . This should be null for long-running / never-terminating coroutines (e.g. flow.collect). onError Optional custom error handler. block the coroutine code which will be invoked in the context of the provided scope.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/launcher-scope/","text":"// reactivestate / com.ensody.reactivestate / SimpleCoroutineLauncher / launcherScope launcherScope \u00b6 [common] Content override val launcherScope : CoroutineScope More info The underlying CoroutineScope of this launcher.","title":"Launcher scope"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/launcher-scope/#launcherscope","text":"[common] Content override val launcherScope : CoroutineScope More info The underlying CoroutineScope of this launcher.","title":"launcherScope"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/loading/","text":"// reactivestate / com.ensody.reactivestate / SimpleCoroutineLauncher / loading loading \u00b6 [common] Content override val loading : MutableValueFlow < Int > More info The default loading tracker. Use increment / decrement to safely update the loading counter.","title":"Loading"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/loading/#loading","text":"[common] Content override val loading : MutableValueFlow < Int > More info The default loading tracker. Use increment / decrement to safely update the loading counter.","title":"loading"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/on-error/","text":"// reactivestate / com.ensody.reactivestate / SimpleCoroutineLauncher / onError onError \u00b6 [common] Content open fun onError (error: Throwable )","title":"On error"},{"location":"reference/reactivestate/com.ensody.reactivestate/-simple-coroutine-launcher/on-error/#onerror","text":"[common] Content open fun onError (error: Throwable )","title":"onError"},{"location":"reference/reactivestate/com.ensody.reactivestate/-state-flow-store/","text":"// reactivestate / com.ensody.reactivestate / StateFlowStore StateFlowStore \u00b6 [common] interface StateFlowStore Base interface for a temporary observable key-value store. This is useful for multiplatform projects and in general for abstracting away SavedStateHandle, so you can write tests without Robolectric. Functions \u00b6 Name Summary contains Platforms: common abstract operator fun contains (key: String ): Boolean getData Platforms: common abstract fun < T > getData (key: String , default: T ): MutableValueFlow < T > Inheritors \u00b6 Name SavedStateHandleStore InMemoryStateFlowStore NamespacedStateFlowStore Extensions \u00b6 Name Summary getData Platforms: common fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation.","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-state-flow-store/#stateflowstore","text":"[common] interface StateFlowStore Base interface for a temporary observable key-value store. This is useful for multiplatform projects and in general for abstracting away SavedStateHandle, so you can write tests without Robolectric.","title":"StateFlowStore"},{"location":"reference/reactivestate/com.ensody.reactivestate/-state-flow-store/#functions","text":"Name Summary contains Platforms: common abstract operator fun contains (key: String ): Boolean getData Platforms: common abstract fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-state-flow-store/#inheritors","text":"Name SavedStateHandleStore InMemoryStateFlowStore NamespacedStateFlowStore","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-state-flow-store/#extensions","text":"Name Summary getData Platforms: common fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation.","title":"Extensions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-state-flow-store/contains/","text":"// reactivestate / com.ensody.reactivestate / StateFlowStore / contains contains \u00b6 [common] Content abstract operator fun contains (key: String ): Boolean","title":"Contains"},{"location":"reference/reactivestate/com.ensody.reactivestate/-state-flow-store/contains/#contains","text":"[common] Content abstract operator fun contains (key: String ): Boolean","title":"contains"},{"location":"reference/reactivestate/com.ensody.reactivestate/-state-flow-store/get-data/","text":"// reactivestate / com.ensody.reactivestate / StateFlowStore / getData getData \u00b6 [common] Content abstract fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Get data"},{"location":"reference/reactivestate/com.ensody.reactivestate/-state-flow-store/get-data/#getdata","text":"[common] Content abstract fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"getData"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/","text":"// reactivestate / com.ensody.reactivestate / SuspendMutableValueFlow SuspendMutableValueFlow \u00b6 [common] @ ExperimentalReactiveStateApi () interface SuspendMutableValueFlow < T > : ValueFlow < T > A StateFlow that can be mutated only via suspend functions - in contrast to assigning the value . This is useful e.g. for values backed by some storage/backend system. See also \u00b6 common com.ensody.reactivestate.BaseSuspendMutableValueFlow which can be a useful base class for your custom implementation. Functions \u00b6 Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector< T >) replace Platforms: common abstract suspend fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value. set Platforms: common abstract suspend fun set (value: T , force: Boolean = false) Assigns a new value . update Platforms: common abstract suspend fun update (block: ( T ) -> Unit ) Mutates value in-place and notifies listeners. updateThis Platforms: common abstract suspend fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. Properties \u00b6 Name Summary replayCache [common] abstract val replayCache : List < T > value [common] abstract val value : T Inheritors \u00b6 Name BaseSuspendMutableValueFlow","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/#suspendmutablevalueflow","text":"[common] @ ExperimentalReactiveStateApi () interface SuspendMutableValueFlow < T > : ValueFlow < T > A StateFlow that can be mutated only via suspend functions - in contrast to assigning the value . This is useful e.g. for values backed by some storage/backend system.","title":"SuspendMutableValueFlow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/#see-also","text":"common com.ensody.reactivestate.BaseSuspendMutableValueFlow which can be a useful base class for your custom implementation.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/#functions","text":"Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector< T >) replace Platforms: common abstract suspend fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value. set Platforms: common abstract suspend fun set (value: T , force: Boolean = false) Assigns a new value . update Platforms: common abstract suspend fun update (block: ( T ) -> Unit ) Mutates value in-place and notifies listeners. updateThis Platforms: common abstract suspend fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/#properties","text":"Name Summary replayCache [common] abstract val replayCache : List < T > value [common] abstract val value : T","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/#inheritors","text":"Name BaseSuspendMutableValueFlow","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/replace/","text":"// reactivestate / com.ensody.reactivestate / SuspendMutableValueFlow / replace replace \u00b6 [common] Content abstract suspend fun replace (block: T .() -> T ) More info Replaces the value with block \u2018s return value.","title":"Replace"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/replace/#replace","text":"[common] Content abstract suspend fun replace (block: T .() -> T ) More info Replaces the value with block \u2018s return value.","title":"replace"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/set/","text":"// reactivestate / com.ensody.reactivestate / SuspendMutableValueFlow / set set \u00b6 [common] Content abstract suspend fun set (value: T , force: Boolean = false) More info Assigns a new value . Parameters \u00b6 common value The new value to be assigned. force Whether to assign even if value is unchanged. Defaults to false, behaving like MutableStateFlow.","title":"Set"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/set/#set","text":"[common] Content abstract suspend fun set (value: T , force: Boolean = false) More info Assigns a new value .","title":"set"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/set/#parameters","text":"common value The new value to be assigned. force Whether to assign even if value is unchanged. Defaults to false, behaving like MutableStateFlow.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/update-this/","text":"// reactivestate / com.ensody.reactivestate / SuspendMutableValueFlow / updateThis updateThis \u00b6 [common] Content abstract suspend fun updateThis (block: T .() -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed via this.","title":"Update this"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/update-this/#updatethis","text":"[common] Content abstract suspend fun updateThis (block: T .() -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed via this.","title":"updateThis"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/update/","text":"// reactivestate / com.ensody.reactivestate / SuspendMutableValueFlow / update update \u00b6 [common] Content abstract suspend fun update (block: ( T ) -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"Update"},{"location":"reference/reactivestate/com.ensody.reactivestate/-suspend-mutable-value-flow/update/#update","text":"[common] Content abstract suspend fun update (block: ( T ) -> Unit ) More info Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"update"},{"location":"reference/reactivestate/com.ensody.reactivestate/-value-flow/","text":"// reactivestate / com.ensody.reactivestate / ValueFlow ValueFlow \u00b6 [common] interface ValueFlow < T > : StateFlow< T > A version of StateFlow that can explicitly trigger value changes without equality checks. Functions \u00b6 Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector< T >) Properties \u00b6 Name Summary replayCache [common] abstract val replayCache : List < T > value [common] abstract val value : T Inheritors \u00b6 Name SuspendMutableValueFlow BaseSuspendMutableValueFlow MutableValueFlow","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-value-flow/#valueflow","text":"[common] interface ValueFlow < T > : StateFlow< T > A version of StateFlow that can explicitly trigger value changes without equality checks.","title":"ValueFlow"},{"location":"reference/reactivestate/com.ensody.reactivestate/-value-flow/#functions","text":"Name Summary collect Platforms: common abstract suspend fun collect (collector: FlowCollector< T >)","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-value-flow/#properties","text":"Name Summary replayCache [common] abstract val replayCache : List < T > value [common] abstract val value : T","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-value-flow/#inheritors","text":"Name SuspendMutableValueFlow BaseSuspendMutableValueFlow MutableValueFlow","title":"Inheritors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/","text":"// reactivestate / com.ensody.reactivestate / WhileUsed WhileUsed \u00b6 [common] class WhileUsed < T >( retentionMillis : Long , destructor : ( T ) -> Unit ?, builder : ( WhileUsedReferenceToken ) -> T ) A reference-counted value that is created on-demand and freed once nobody uses it (whereas by lazy is never freed). WhileUsed is useful for e.g. caches or other resource-consuming values that shouldn\u2019t live forever, but only exist while they\u2019re in use. Sometimes this can also be helpful for dealing with security-critical data. This can be a great combination with SharingStarted.WhileSubscribed and either derived or Flow.stateIn/Flow.shareIn, for example. In order to request the value with invoke you need a CoroutineScope or a DisposableGroup . Note: Your builder function is also passed a DisposableGroup for accessing other WhileUsed instances. The CoroutineScope/ DisposableGroup is used to track the requester\u2019s lifetime and in turn the reference count. As an alternative when you don\u2019t have a CoroutineScope you can also use disposableValue , but this is more error-prone because it\u2019s easier to forget. Typically you\u2019d place such values in your DI system and have one or more ViewModels or UI screens or widgets requesting the value. Once these screens/widgets/ViewModels are destroyed (e.g. because the user pressed on the back button) the value is freed again. Example: val createDatabase = WhileUsed { Database() } val createCache = WhileUsed { DbCache(createDatabase(it)) } class MyViewModel : ViewModel() { val cache = createCache(viewModelScope) } Parameters \u00b6 common retentionMillis Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0. If the value is requested again within this retention period, the old value is reused. Defaults to 0 (immediately frees the value). destructor Optional destructor which can clean up the object before it gets freed. Defaults to null in which case, if the value is a Disposable , its dispose() method is called. Pass an empty lambda function if you don\u2019t want this behavior. builder Should create and return the value. The builder gets a DisposableGroup as its argument for retrieving other WhileUsed values or for adding other Disposable s which must be cleaned up together with this value (as an alternative to using destructor). Constructors \u00b6 WhileUsed [common] fun < T > WhileUsed (retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T )Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0. Functions \u00b6 Name Summary disposableValue Platforms: common fun disposableValue (): DisposableValue < T > Creates or returns the existing value while incrementing the reference count. invoke Platforms: common operator fun invoke (referenceToken: DisposableGroup ): T operator fun invoke (userScope: CoroutineScope): T Creates or returns the existing value while incrementing the reference count.","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/#whileused","text":"[common] class WhileUsed < T >( retentionMillis : Long , destructor : ( T ) -> Unit ?, builder : ( WhileUsedReferenceToken ) -> T ) A reference-counted value that is created on-demand and freed once nobody uses it (whereas by lazy is never freed). WhileUsed is useful for e.g. caches or other resource-consuming values that shouldn\u2019t live forever, but only exist while they\u2019re in use. Sometimes this can also be helpful for dealing with security-critical data. This can be a great combination with SharingStarted.WhileSubscribed and either derived or Flow.stateIn/Flow.shareIn, for example. In order to request the value with invoke you need a CoroutineScope or a DisposableGroup . Note: Your builder function is also passed a DisposableGroup for accessing other WhileUsed instances. The CoroutineScope/ DisposableGroup is used to track the requester\u2019s lifetime and in turn the reference count. As an alternative when you don\u2019t have a CoroutineScope you can also use disposableValue , but this is more error-prone because it\u2019s easier to forget. Typically you\u2019d place such values in your DI system and have one or more ViewModels or UI screens or widgets requesting the value. Once these screens/widgets/ViewModels are destroyed (e.g. because the user pressed on the back button) the value is freed again. Example: val createDatabase = WhileUsed { Database() } val createCache = WhileUsed { DbCache(createDatabase(it)) } class MyViewModel : ViewModel() { val cache = createCache(viewModelScope) }","title":"WhileUsed"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/#parameters","text":"common retentionMillis Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0. If the value is requested again within this retention period, the old value is reused. Defaults to 0 (immediately frees the value). destructor Optional destructor which can clean up the object before it gets freed. Defaults to null in which case, if the value is a Disposable , its dispose() method is called. Pass an empty lambda function if you don\u2019t want this behavior. builder Should create and return the value. The builder gets a DisposableGroup as its argument for retrieving other WhileUsed values or for adding other Disposable s which must be cleaned up together with this value (as an alternative to using destructor).","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/#constructors","text":"WhileUsed [common] fun < T > WhileUsed (retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T )Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0.","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/#functions","text":"Name Summary disposableValue Platforms: common fun disposableValue (): DisposableValue < T > Creates or returns the existing value while incrementing the reference count. invoke Platforms: common operator fun invoke (referenceToken: DisposableGroup ): T operator fun invoke (userScope: CoroutineScope): T Creates or returns the existing value while incrementing the reference count.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/-while-used/","text":"// reactivestate / com.ensody.reactivestate / WhileUsed / WhileUsed WhileUsed \u00b6 [common] Content fun < T > WhileUsed (retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T ) More info Parameters \u00b6 common retentionMillis Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0. If the value is requested again within this retention period, the old value is reused. Defaults to 0 (immediately frees the value). destructor Optional destructor which can clean up the object before it gets freed. Defaults to null in which case, if the value is a Disposable , its dispose() method is called. Pass an empty lambda function if you don\u2019t want this behavior. builder Should create and return the value. The builder gets a DisposableGroup as its argument for retrieving other WhileUsed values or for adding other Disposable s which must be cleaned up together with this value (as an alternative to using destructor).","title":" while used"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/-while-used/#whileused","text":"[common] Content fun < T > WhileUsed (retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T ) More info","title":"WhileUsed"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/-while-used/#parameters","text":"common retentionMillis Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0. If the value is requested again within this retention period, the old value is reused. Defaults to 0 (immediately frees the value). destructor Optional destructor which can clean up the object before it gets freed. Defaults to null in which case, if the value is a Disposable , its dispose() method is called. Pass an empty lambda function if you don\u2019t want this behavior. builder Should create and return the value. The builder gets a DisposableGroup as its argument for retrieving other WhileUsed values or for adding other Disposable s which must be cleaned up together with this value (as an alternative to using destructor).","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/disposable-value/","text":"// reactivestate / com.ensody.reactivestate / WhileUsed / disposableValue disposableValue \u00b6 [common] Content fun disposableValue (): DisposableValue < T > More info Creates or returns the existing value while incrementing the reference count. You really want invoke instead. IMPORTANT: You have to call dispose() on the returned value once you stop using it.","title":"Disposable value"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/disposable-value/#disposablevalue","text":"[common] Content fun disposableValue (): DisposableValue < T > More info Creates or returns the existing value while incrementing the reference count. You really want invoke instead. IMPORTANT: You have to call dispose() on the returned value once you stop using it.","title":"disposableValue"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/invoke/","text":"// reactivestate / com.ensody.reactivestate / WhileUsed / invoke invoke \u00b6 [common] Content operator fun invoke (userScope: CoroutineScope): T More info Creates or returns the existing value while incrementing the reference count. When the given userScope is canceled the reference count is decremented. Once the count is 0 the value is freed. [common] Content operator fun invoke (referenceToken: DisposableGroup ): T More info Creates or returns the existing value while incrementing the reference count. When the given referenceToken is disposed the reference count is decremented. Once the count is 0 the value is freed.","title":"Invoke"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used/invoke/#invoke","text":"[common] Content operator fun invoke (userScope: CoroutineScope): T More info Creates or returns the existing value while incrementing the reference count. When the given userScope is canceled the reference count is decremented. Once the count is 0 the value is freed. [common] Content operator fun invoke (referenceToken: DisposableGroup ): T More info Creates or returns the existing value while incrementing the reference count. When the given referenceToken is disposed the reference count is decremented. Once the count is 0 the value is freed.","title":"invoke"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used-reference-token/","text":"// reactivestate / com.ensody.reactivestate / WhileUsedReferenceToken WhileUsedReferenceToken \u00b6 [common] class WhileUsedReferenceToken : DisposableGroup The reference token passed to the WhileUsed builder function. Constructors \u00b6 WhileUsedReferenceToken [common] fun WhileUsedReferenceToken () Functions \u00b6 Name Summary add Platforms: common open override fun add (disposable: Disposable ) Add a Disposable to this group. Platforms: common open override fun add (job: Job) Add a Job to this group. dispose Platforms: common open override fun dispose () remove Platforms: common open override fun remove (disposable: Disposable ) Remove a Disposable from this group. Platforms: common open override fun remove (job: Job) Remove a Job from this group. Properties \u00b6 Name Summary scope [common] val scope : CoroutineScopeA lazily created MainScope that lives only as long as the WhileUsed value. size [common] open override val size : Int","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used-reference-token/#whileusedreferencetoken","text":"[common] class WhileUsedReferenceToken : DisposableGroup The reference token passed to the WhileUsed builder function.","title":"WhileUsedReferenceToken"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used-reference-token/#constructors","text":"WhileUsedReferenceToken [common] fun WhileUsedReferenceToken ()","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used-reference-token/#functions","text":"Name Summary add Platforms: common open override fun add (disposable: Disposable ) Add a Disposable to this group. Platforms: common open override fun add (job: Job) Add a Job to this group. dispose Platforms: common open override fun dispose () remove Platforms: common open override fun remove (disposable: Disposable ) Remove a Disposable from this group. Platforms: common open override fun remove (job: Job) Remove a Job from this group.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used-reference-token/#properties","text":"Name Summary scope [common] val scope : CoroutineScopeA lazily created MainScope that lives only as long as the WhileUsed value. size [common] open override val size : Int","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used-reference-token/-while-used-reference-token/","text":"// reactivestate / com.ensody.reactivestate / WhileUsedReferenceToken / WhileUsedReferenceToken WhileUsedReferenceToken \u00b6 [common] Content fun WhileUsedReferenceToken ()","title":" while used reference token"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used-reference-token/-while-used-reference-token/#whileusedreferencetoken","text":"[common] Content fun WhileUsedReferenceToken ()","title":"WhileUsedReferenceToken"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used-reference-token/scope/","text":"// reactivestate / com.ensody.reactivestate / WhileUsedReferenceToken / scope scope \u00b6 [common] Content val scope : CoroutineScope More info A lazily created MainScope that lives only as long as the WhileUsed value.","title":"Scope"},{"location":"reference/reactivestate/com.ensody.reactivestate/-while-used-reference-token/scope/#scope","text":"[common] Content val scope : CoroutineScope More info A lazily created MainScope that lives only as long as the WhileUsed value.","title":"scope"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/","text":"// reactivestate / com.ensody.reactivestate.android Package com.ensody.reactivestate.android \u00b6 Types \u00b6 Name Summary BuildOnViewModelContext Platforms: android class BuildOnViewModelContext ( scope : CoroutineScope, stateFlowStore : StateFlowStore ) Build context for buildOnViewModel . LifecycleCoroutineLauncher Platforms: android class LifecycleCoroutineLauncher ( owner : LifecycleOwner ) : SimpleCoroutineLauncher A SimpleCoroutineLauncher that launches coroutines in the STARTED state. SavedStateHandleStore Platforms: android class SavedStateHandleStore ( scope : CoroutineScope?, savedStateHandle : SavedStateHandle ) : StateFlowStore A StateFlowStore that wraps a SavedStateHandle . WrapperViewModel Platforms: android class WrapperViewModel ( stateFlowStore : StateFlowStore ) : ViewModel The wrapper ViewModel used by buildOnViewModel . Functions \u00b6 Name Summary activityStateFlowViewModel Platforms: android inline fun < T : ViewModel > Fragment . activityStateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore , scoped to the Activity. activityStateViewModel Platforms: android inline fun < T : ViewModel > Fragment . activityStateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle, scoped to the Activity. activityViewModel Platforms: android inline fun < T : ViewModel > Fragment . activityViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel scoped to the Activity. attachLazyReactiveState Platforms: android fun < E : ErrorEvents > Lazy < ReactiveState < E >>. attachLazyReactiveState (handler: E ?, owner: LifecycleOwner ) autoRun Platforms: android fun LifecycleOwner . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner < Unit > fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner < Unit > Watches observables for changes. buildOnViewModel Platforms: android inline fun < T : Any > ComponentActivity . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel. Platforms: android inline fun < T : Any > Fragment . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . Platforms: android fun < T : Any > Lazy < WrapperViewModel >. buildOnViewModel (klass: KClass < T >, caster: ( Any ?) -> T ?, provider: BuildOnViewModelContext .() -> T ): Lazy < T > Used internally by buildOnViewModel . buildViewModel Platforms: android inline fun < T : ViewModel > ComponentActivity . buildViewModel (crossinline provider: () -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . buildViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel. coAutoRun Platforms: android fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner < Unit > fun LifecycleOwner . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback< Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: AutoRunCallback< Unit >): CoAutoRunner < Unit > Watches observables for changes. derived Platforms: android fun < T > LifecycleOwner . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), observer: AutoRunCallback< T >): StateFlow< T > fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. Platforms: android fun < T > LifecycleOwner . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. get Platforms: android fun < T > Resolver . get (data: LiveData < T >): T ? Returns LiveData.getValue and tracks the observable. handleEvents Platforms: android fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T , owner: LifecycleOwner ) Consumes and handles EventNotifier \u2018s events on the given handler , but only when owner is in >=STARTED state. onCreate Platforms: android fun LifecycleOwner . onCreate (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_CREATE. onCreateOnce Platforms: android fun LifecycleOwner . onCreateOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY. onCreateView Platforms: android fun Fragment . onCreateView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onCreateView (actually onViewStateRestored). onCreateViewOnce Platforms: android fun Fragment . onCreateViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onCreateView (actually onViewStateRestored). onDestroy Platforms: android fun LifecycleOwner . onDestroy (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_DESTROY. onDestroyOnce Platforms: android fun LifecycleOwner . onDestroyOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY. onDestroyView Platforms: android fun Fragment . onDestroyView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onDestroyView. onDestroyViewOnce Platforms: android fun Fragment . onDestroyViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onDestroyView. onPause Platforms: android fun LifecycleOwner . onPause (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_PAUSE. onPauseOnce Platforms: android fun LifecycleOwner . onPauseOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_PAUSE. onResume Platforms: android fun LifecycleOwner . onResume (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_RESUME. onResumeOnce Platforms: android fun LifecycleOwner . onResumeOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_RESUME. onStart Platforms: android fun LifecycleOwner . onStart (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_START. onStartOnce Platforms: android fun LifecycleOwner . onStartOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_START. onStop Platforms: android fun LifecycleOwner . onStop (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_STOP. onStopOnce Platforms: android fun LifecycleOwner . onStopOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_STOP. reactiveState Platforms: android inline fun < E : ErrorEvents , T : ReactiveState < E >> ComponentActivity . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > inline fun < E : ErrorEvents , T : ReactiveState < E >> Fragment . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates a multiplatform ReactiveState ViewModel and observes its ReactiveState.eventNotifier . savedInstanceState Platforms: android fun < T > ComponentActivity . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> fun < T > Fragment . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> Returns a StateFlowStore where you can put your saved instance state. stateFlowStore Platforms: android fun SavedStateHandle . stateFlowStore (scope: CoroutineScope): SavedStateHandleStore stateFlowViewModel Platforms: android inline fun < T : ViewModel > ComponentActivity . stateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateFlowViewModel (crossinline provider: (store: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore . stateViewModel Platforms: android inline fun < T : ViewModel > ComponentActivity . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle. Properties \u00b6 Name Summary savedInstanceState [android] val Fragment . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state. savedInstanceState [android] val ComponentActivity . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state.","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/#package-comensodyreactivestateandroid","text":"","title":"Package com.ensody.reactivestate.android"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/#types","text":"Name Summary BuildOnViewModelContext Platforms: android class BuildOnViewModelContext ( scope : CoroutineScope, stateFlowStore : StateFlowStore ) Build context for buildOnViewModel . LifecycleCoroutineLauncher Platforms: android class LifecycleCoroutineLauncher ( owner : LifecycleOwner ) : SimpleCoroutineLauncher A SimpleCoroutineLauncher that launches coroutines in the STARTED state. SavedStateHandleStore Platforms: android class SavedStateHandleStore ( scope : CoroutineScope?, savedStateHandle : SavedStateHandle ) : StateFlowStore A StateFlowStore that wraps a SavedStateHandle . WrapperViewModel Platforms: android class WrapperViewModel ( stateFlowStore : StateFlowStore ) : ViewModel The wrapper ViewModel used by buildOnViewModel .","title":"Types"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/#functions","text":"Name Summary activityStateFlowViewModel Platforms: android inline fun < T : ViewModel > Fragment . activityStateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore , scoped to the Activity. activityStateViewModel Platforms: android inline fun < T : ViewModel > Fragment . activityStateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle, scoped to the Activity. activityViewModel Platforms: android inline fun < T : ViewModel > Fragment . activityViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel scoped to the Activity. attachLazyReactiveState Platforms: android fun < E : ErrorEvents > Lazy < ReactiveState < E >>. attachLazyReactiveState (handler: E ?, owner: LifecycleOwner ) autoRun Platforms: android fun LifecycleOwner . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner < Unit > fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner < Unit > Watches observables for changes. buildOnViewModel Platforms: android inline fun < T : Any > ComponentActivity . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel. Platforms: android inline fun < T : Any > Fragment . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . Platforms: android fun < T : Any > Lazy < WrapperViewModel >. buildOnViewModel (klass: KClass < T >, caster: ( Any ?) -> T ?, provider: BuildOnViewModelContext .() -> T ): Lazy < T > Used internally by buildOnViewModel . buildViewModel Platforms: android inline fun < T : ViewModel > ComponentActivity . buildViewModel (crossinline provider: () -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . buildViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel. coAutoRun Platforms: android fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner < Unit > fun LifecycleOwner . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback< Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: AutoRunCallback< Unit >): CoAutoRunner < Unit > Watches observables for changes. derived Platforms: android fun < T > LifecycleOwner . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), observer: AutoRunCallback< T >): StateFlow< T > fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. Platforms: android fun < T > LifecycleOwner . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. get Platforms: android fun < T > Resolver . get (data: LiveData < T >): T ? Returns LiveData.getValue and tracks the observable. handleEvents Platforms: android fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T , owner: LifecycleOwner ) Consumes and handles EventNotifier \u2018s events on the given handler , but only when owner is in >=STARTED state. onCreate Platforms: android fun LifecycleOwner . onCreate (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_CREATE. onCreateOnce Platforms: android fun LifecycleOwner . onCreateOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY. onCreateView Platforms: android fun Fragment . onCreateView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onCreateView (actually onViewStateRestored). onCreateViewOnce Platforms: android fun Fragment . onCreateViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onCreateView (actually onViewStateRestored). onDestroy Platforms: android fun LifecycleOwner . onDestroy (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_DESTROY. onDestroyOnce Platforms: android fun LifecycleOwner . onDestroyOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY. onDestroyView Platforms: android fun Fragment . onDestroyView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onDestroyView. onDestroyViewOnce Platforms: android fun Fragment . onDestroyViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onDestroyView. onPause Platforms: android fun LifecycleOwner . onPause (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_PAUSE. onPauseOnce Platforms: android fun LifecycleOwner . onPauseOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_PAUSE. onResume Platforms: android fun LifecycleOwner . onResume (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_RESUME. onResumeOnce Platforms: android fun LifecycleOwner . onResumeOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_RESUME. onStart Platforms: android fun LifecycleOwner . onStart (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_START. onStartOnce Platforms: android fun LifecycleOwner . onStartOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_START. onStop Platforms: android fun LifecycleOwner . onStop (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_STOP. onStopOnce Platforms: android fun LifecycleOwner . onStopOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_STOP. reactiveState Platforms: android inline fun < E : ErrorEvents , T : ReactiveState < E >> ComponentActivity . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > inline fun < E : ErrorEvents , T : ReactiveState < E >> Fragment . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates a multiplatform ReactiveState ViewModel and observes its ReactiveState.eventNotifier . savedInstanceState Platforms: android fun < T > ComponentActivity . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> fun < T > Fragment . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> Returns a StateFlowStore where you can put your saved instance state. stateFlowStore Platforms: android fun SavedStateHandle . stateFlowStore (scope: CoroutineScope): SavedStateHandleStore stateFlowViewModel Platforms: android inline fun < T : ViewModel > ComponentActivity . stateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateFlowViewModel (crossinline provider: (store: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore . stateViewModel Platforms: android inline fun < T : ViewModel > ComponentActivity . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/#properties","text":"Name Summary savedInstanceState [android] val Fragment . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state. savedInstanceState [android] val ComponentActivity . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state.","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-flow-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / activityStateFlowViewModel activityStateFlowViewModel \u00b6 [android] Content inline fun < T : ViewModel > Fragment . activityStateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandleStore , scoped to the Activity. The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"Activity state flow view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-flow-view-model/#activitystateflowviewmodel","text":"[android] Content inline fun < T : ViewModel > Fragment . activityStateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandleStore , scoped to the Activity. The provider should instantiate the ViewModel directly.","title":"activityStateFlowViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-flow-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / activityStateViewModel activityStateViewModel \u00b6 [android] Content inline fun < T : ViewModel > Fragment . activityStateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandle, scoped to the Activity. The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"Activity state view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-view-model/#activitystateviewmodel","text":"[android] Content inline fun < T : ViewModel > Fragment . activityStateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandle, scoped to the Activity. The provider should instantiate the ViewModel directly.","title":"activityStateViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / activityViewModel activityViewModel \u00b6 [android] Content inline fun < T : ViewModel > Fragment . activityViewModel (crossinline provider: () -> T ): Lazy < T > More info Creates a ViewModel scoped to the Activity. The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"Activity view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-view-model/#activityviewmodel","text":"[android] Content inline fun < T : ViewModel > Fragment . activityViewModel (crossinline provider: () -> T ): Lazy < T > More info Creates a ViewModel scoped to the Activity. The provider should instantiate the ViewModel directly.","title":"activityViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/attach-lazy-reactive-state/","text":"// reactivestate / com.ensody.reactivestate.android / attachLazyReactiveState attachLazyReactiveState \u00b6 [android] Content fun < E : ErrorEvents > Lazy < ReactiveState < E >>. attachLazyReactiveState (handler: E ?, owner: LifecycleOwner )","title":"Attach lazy reactive state"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/attach-lazy-reactive-state/#attachlazyreactivestate","text":"[android] Content fun < E : ErrorEvents > Lazy < ReactiveState < E >>. attachLazyReactiveState (handler: E ?, owner: LifecycleOwner )","title":"attachLazyReactiveState"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/auto-run/","text":"// reactivestate / com.ensody.reactivestate.android / autoRun autoRun \u00b6 [android] Content fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync. This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the viewModelScope completes. See AutoRunner for more details. Parameters \u00b6 android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [android] Content fun LifecycleOwner . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This only executes the observer between onStart/onStop. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed on Activity.onDestroy/Fragment.onDestroyView. See AutoRunner for more details. Parameters \u00b6 android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables.","title":"Auto run"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/auto-run/#autorun","text":"[android] Content fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync. This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the viewModelScope completes. See AutoRunner for more details.","title":"autoRun"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/auto-run/#parameters","text":"android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [android] Content fun LifecycleOwner . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This only executes the observer between onStart/onStop. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed on Activity.onDestroy/Fragment.onDestroyView. See AutoRunner for more details.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/auto-run/#parameters_1","text":"android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-on-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / buildOnViewModel buildOnViewModel \u00b6 [android] Content inline fun < T : Any > Fragment . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > More info Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. The provider should instantiate the object directly. See also \u00b6 android reactiveState if you want to instantiate a multiplatform ReactiveState ViewModel directly. [android] Content inline fun < T : Any > ComponentActivity . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > More info Creates an object living on a wrapper ViewModel. This allows for building multiplatform ViewModels. The provider should instantiate the object directly. See also \u00b6 android reactiveState if you want to instantiate a multiplatform ReactiveState ViewModel directly. [android] Content fun < T : Any > Lazy < WrapperViewModel >. buildOnViewModel (klass: KClass < T >, caster: ( Any ?) -> T ?, provider: BuildOnViewModelContext .() -> T ): Lazy < T > More info Used internally by buildOnViewModel .","title":"Build on view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-on-view-model/#buildonviewmodel","text":"[android] Content inline fun < T : Any > Fragment . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > More info Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. The provider should instantiate the object directly.","title":"buildOnViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-on-view-model/#see-also","text":"android reactiveState if you want to instantiate a multiplatform ReactiveState ViewModel directly. [android] Content inline fun < T : Any > ComponentActivity . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > More info Creates an object living on a wrapper ViewModel. This allows for building multiplatform ViewModels. The provider should instantiate the object directly.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-on-view-model/#see-also_1","text":"android reactiveState if you want to instantiate a multiplatform ReactiveState ViewModel directly. [android] Content fun < T : Any > Lazy < WrapperViewModel >. buildOnViewModel (klass: KClass < T >, caster: ( Any ?) -> T ?, provider: BuildOnViewModelContext .() -> T ): Lazy < T > More info Used internally by buildOnViewModel .","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / buildViewModel buildViewModel \u00b6 [android] Content inline fun < T : ViewModel > Fragment . buildViewModel (crossinline provider: () -> T ): Lazy < T > More info Creates a ViewModel. The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels. [android] Content inline fun < T : ViewModel > ComponentActivity . buildViewModel (crossinline provider: () -> T ): Lazy < T > More info Creates a ViewModel. The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"Build view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-view-model/#buildviewmodel","text":"[android] Content inline fun < T : ViewModel > Fragment . buildViewModel (crossinline provider: () -> T ): Lazy < T > More info Creates a ViewModel. The provider should instantiate the ViewModel directly.","title":"buildViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels. [android] Content inline fun < T : ViewModel > ComponentActivity . buildViewModel (crossinline provider: () -> T ): Lazy < T > More info Creates a ViewModel. The provider should instantiate the ViewModel directly.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-view-model/#see-also_1","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/co-auto-run/","text":"// reactivestate / com.ensody.reactivestate.android / coAutoRun coAutoRun \u00b6 [android] Content fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync. This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the viewModelScope completes. See AutoRunner for more details. Parameters \u00b6 android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [android] Content fun LifecycleOwner . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback< Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: AutoRunCallback< Unit >): CoAutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This only executes the observer between onStart/onStop. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed on Activity.onDestroy/Fragment.onDestroyView. See AutoRunner for more details. Parameters \u00b6 android onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables.","title":"Co auto run"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/co-auto-run/#coautorun","text":"[android] Content fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync. This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the viewModelScope completes. See AutoRunner for more details.","title":"coAutoRun"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/co-auto-run/#parameters","text":"android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [android] Content fun LifecycleOwner . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback< Unit >? = null, flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: AutoRunCallback< Unit >): CoAutoRunner < Unit > More info Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This only executes the observer between onStart/onStop. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed on Activity.onDestroy/Fragment.onDestroyView. See AutoRunner for more details.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/co-auto-run/#parameters_1","text":"android onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/derived/","text":"// reactivestate / com.ensody.reactivestate.android / derived derived \u00b6 [android] Content fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > fun < T > LifecycleOwner . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), observer: AutoRunCallback< T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. [android] Content fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed. Parameters \u00b6 android initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables. [android] Content fun < T > LifecycleOwner . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed. Parameters \u00b6 android initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables.","title":"Derived"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/derived/#derived","text":"[android] Content fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > fun < T > LifecycleOwner . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), observer: AutoRunCallback< T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. [android] Content fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed.","title":"derived"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/derived/#parameters","text":"android initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables. [android] Content fun < T > LifecycleOwner . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), flowTransformer: AutoRunFlowTransformer = defaultAutoRunFlowTransformer, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > More info Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/derived/#parameters_1","text":"android initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to { conflatedWorker() }. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default. withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/get/","text":"// reactivestate / com.ensody.reactivestate.android / get get \u00b6 [android] Content fun < T > Resolver . get (data: LiveData < T >): T ? More info Returns LiveData.getValue and tracks the observable.","title":"Get"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/get/#get","text":"[android] Content fun < T > Resolver . get (data: LiveData < T >): T ? More info Returns LiveData.getValue and tracks the observable.","title":"get"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/handle-events/","text":"// reactivestate / com.ensody.reactivestate.android / handleEvents handleEvents \u00b6 [android] Content fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T , owner: LifecycleOwner ) More info Consumes and handles EventNotifier \u2018s events on the given handler , but only when owner is in >=STARTED state. IMPORTANT: You have to call this function exactly once for the whole lifecycle of owner . Usually that means Activity.onCreate/Fragment.onViewCreated. Any errors during event handling will trigger ErrorEvents.onError on the handler . WARNING: Try to avoid switching threads within your handler \u2018s methods! Otherwise your operation can get canceled and lost when rotating or locking the screen. Always stay on the main thread.","title":"Handle events"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/handle-events/#handleevents","text":"[android] Content fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T , owner: LifecycleOwner ) More info Consumes and handles EventNotifier \u2018s events on the given handler , but only when owner is in >=STARTED state. IMPORTANT: You have to call this function exactly once for the whole lifecycle of owner . Usually that means Activity.onCreate/Fragment.onViewCreated. Any errors during event handling will trigger ErrorEvents.onError on the handler . WARNING: Try to avoid switching threads within your handler \u2018s methods! Otherwise your operation can get canceled and lost when rotating or locking the screen. Always stay on the main thread.","title":"handleEvents"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-once/","text":"// reactivestate / com.ensody.reactivestate.android / onCreateOnce onCreateOnce \u00b6 [android] Content fun LifecycleOwner . onCreateOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_DESTROY. Return \u00b6 Disposable that allows removing the observer.","title":"On create once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-once/#oncreateonce","text":"[android] Content fun LifecycleOwner . onCreateOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_DESTROY.","title":"onCreateOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view-once/","text":"// reactivestate / com.ensody.reactivestate.android / onCreateViewOnce onCreateViewOnce \u00b6 [android] Content fun Fragment . onCreateViewOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Fragment.onCreateView (actually onViewStateRestored). Return \u00b6 Disposable that allows removing the observer.","title":"On create view once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view-once/#oncreateviewonce","text":"[android] Content fun Fragment . onCreateViewOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Fragment.onCreateView (actually onViewStateRestored).","title":"onCreateViewOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view/","text":"// reactivestate / com.ensody.reactivestate.android / onCreateView onCreateView \u00b6 [android] Content fun Fragment . onCreateView (block: () -> Unit ): Disposable More info Runs the given block on every Fragment.onCreateView (actually onViewStateRestored). Return \u00b6 Disposable that allows removing the observer.","title":"On create view"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view/#oncreateview","text":"[android] Content fun Fragment . onCreateView (block: () -> Unit ): Disposable More info Runs the given block on every Fragment.onCreateView (actually onViewStateRestored).","title":"onCreateView"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create/","text":"// reactivestate / com.ensody.reactivestate.android / onCreate onCreate \u00b6 [android] Content fun LifecycleOwner . onCreate (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_CREATE. Return \u00b6 Disposable that allows removing the observer.","title":"On create"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create/#oncreate","text":"[android] Content fun LifecycleOwner . onCreate (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_CREATE.","title":"onCreate"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-once/","text":"// reactivestate / com.ensody.reactivestate.android / onDestroyOnce onDestroyOnce \u00b6 [android] Content fun LifecycleOwner . onDestroyOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_DESTROY. Return \u00b6 Disposable that allows removing the observer.","title":"On destroy once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-once/#ondestroyonce","text":"[android] Content fun LifecycleOwner . onDestroyOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_DESTROY.","title":"onDestroyOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view-once/","text":"// reactivestate / com.ensody.reactivestate.android / onDestroyViewOnce onDestroyViewOnce \u00b6 [android] Content fun Fragment . onDestroyViewOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Fragment.onDestroyView. Return \u00b6 Disposable that allows removing the observer.","title":"On destroy view once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view-once/#ondestroyviewonce","text":"[android] Content fun Fragment . onDestroyViewOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Fragment.onDestroyView.","title":"onDestroyViewOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view/","text":"// reactivestate / com.ensody.reactivestate.android / onDestroyView onDestroyView \u00b6 [android] Content fun Fragment . onDestroyView (block: () -> Unit ): Disposable More info Runs the given block on every Fragment.onDestroyView. Return \u00b6 Disposable that allows removing the observer.","title":"On destroy view"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view/#ondestroyview","text":"[android] Content fun Fragment . onDestroyView (block: () -> Unit ): Disposable More info Runs the given block on every Fragment.onDestroyView.","title":"onDestroyView"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy/","text":"// reactivestate / com.ensody.reactivestate.android / onDestroy onDestroy \u00b6 [android] Content fun LifecycleOwner . onDestroy (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_DESTROY. Return \u00b6 Disposable that allows removing the observer.","title":"On destroy"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy/#ondestroy","text":"[android] Content fun LifecycleOwner . onDestroy (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_DESTROY.","title":"onDestroy"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause-once/","text":"// reactivestate / com.ensody.reactivestate.android / onPauseOnce onPauseOnce \u00b6 [android] Content fun LifecycleOwner . onPauseOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_PAUSE. Return \u00b6 Disposable that allows removing the observer.","title":"On pause once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause-once/#onpauseonce","text":"[android] Content fun LifecycleOwner . onPauseOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_PAUSE.","title":"onPauseOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause/","text":"// reactivestate / com.ensody.reactivestate.android / onPause onPause \u00b6 [android] Content fun LifecycleOwner . onPause (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_PAUSE. Return \u00b6 Disposable that allows removing the observer.","title":"On pause"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause/#onpause","text":"[android] Content fun LifecycleOwner . onPause (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_PAUSE.","title":"onPause"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume-once/","text":"// reactivestate / com.ensody.reactivestate.android / onResumeOnce onResumeOnce \u00b6 [android] Content fun LifecycleOwner . onResumeOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_RESUME. Return \u00b6 Disposable that allows removing the observer.","title":"On resume once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume-once/#onresumeonce","text":"[android] Content fun LifecycleOwner . onResumeOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_RESUME.","title":"onResumeOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume/","text":"// reactivestate / com.ensody.reactivestate.android / onResume onResume \u00b6 [android] Content fun LifecycleOwner . onResume (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_RESUME. Return \u00b6 Disposable that allows removing the observer.","title":"On resume"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume/#onresume","text":"[android] Content fun LifecycleOwner . onResume (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_RESUME.","title":"onResume"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start-once/","text":"// reactivestate / com.ensody.reactivestate.android / onStartOnce onStartOnce \u00b6 [android] Content fun LifecycleOwner . onStartOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_START. Return \u00b6 Disposable that allows removing the observer.","title":"On start once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start-once/#onstartonce","text":"[android] Content fun LifecycleOwner . onStartOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_START.","title":"onStartOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start/","text":"// reactivestate / com.ensody.reactivestate.android / onStart onStart \u00b6 [android] Content fun LifecycleOwner . onStart (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_START. Return \u00b6 Disposable that allows removing the observer.","title":"On start"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start/#onstart","text":"[android] Content fun LifecycleOwner . onStart (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_START.","title":"onStart"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop-once/","text":"// reactivestate / com.ensody.reactivestate.android / onStopOnce onStopOnce \u00b6 [android] Content fun LifecycleOwner . onStopOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_STOP. Return \u00b6 Disposable that allows removing the observer.","title":"On stop once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop-once/#onstoponce","text":"[android] Content fun LifecycleOwner . onStopOnce (block: () -> Unit ): Disposable More info Runs the given block once on the next Lifecycle.Event.ON_STOP.","title":"onStopOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop/","text":"// reactivestate / com.ensody.reactivestate.android / onStop onStop \u00b6 [android] Content fun LifecycleOwner . onStop (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_STOP. Return \u00b6 Disposable that allows removing the observer.","title":"On stop"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop/#onstop","text":"[android] Content fun LifecycleOwner . onStop (block: () -> Unit ): Disposable More info Runs the given block on every Lifecycle.Event.ON_STOP.","title":"onStop"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/reactive-state/","text":"// reactivestate / com.ensody.reactivestate.android / reactiveState reactiveState \u00b6 [android] Content inline fun < E : ErrorEvents , T : ReactiveState < E >> Fragment . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > inline fun < E : ErrorEvents , T : ReactiveState < E >> ComponentActivity . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > More info Creates a multiplatform ReactiveState ViewModel and observes its ReactiveState.eventNotifier . The provider should instantiate the object directly.","title":"Reactive state"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/reactive-state/#reactivestate","text":"[android] Content inline fun < E : ErrorEvents , T : ReactiveState < E >> Fragment . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > inline fun < E : ErrorEvents , T : ReactiveState < E >> ComponentActivity . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > More info Creates a multiplatform ReactiveState ViewModel and observes its ReactiveState.eventNotifier . The provider should instantiate the object directly.","title":"reactiveState"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/saved-instance-state/","text":"// reactivestate / com.ensody.reactivestate.android / savedInstanceState savedInstanceState \u00b6 [android] Content fun < T > Fragment . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> fun < T > ComponentActivity . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> val Fragment . savedInstanceState : StateFlowStore val ComponentActivity . savedInstanceState : StateFlowStore More info Returns a StateFlowStore where you can put your saved instance state.","title":"Saved instance state"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/saved-instance-state/#savedinstancestate","text":"[android] Content fun < T > Fragment . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> fun < T > ComponentActivity . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> val Fragment . savedInstanceState : StateFlowStore val ComponentActivity . savedInstanceState : StateFlowStore More info Returns a StateFlowStore where you can put your saved instance state.","title":"savedInstanceState"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-store/","text":"// reactivestate / com.ensody.reactivestate.android / stateFlowStore stateFlowStore \u00b6 [android] Content fun SavedStateHandle . stateFlowStore (scope: CoroutineScope): SavedStateHandleStore","title":"State flow store"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-store/#stateflowstore","text":"[android] Content fun SavedStateHandle . stateFlowStore (scope: CoroutineScope): SavedStateHandleStore","title":"stateFlowStore"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / stateFlowViewModel stateFlowViewModel \u00b6 [android] Content inline fun < T : ViewModel > ComponentActivity . stateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandleStore . The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels. [android] Content inline fun < T : ViewModel > Fragment . stateFlowViewModel (crossinline provider: (store: SavedStateHandleStore ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandleStore . The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"State flow view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-view-model/#stateflowviewmodel","text":"[android] Content inline fun < T : ViewModel > ComponentActivity . stateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandleStore . The provider should instantiate the ViewModel directly.","title":"stateFlowViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels. [android] Content inline fun < T : ViewModel > Fragment . stateFlowViewModel (crossinline provider: (store: SavedStateHandleStore ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandleStore . The provider should instantiate the ViewModel directly.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-view-model/#see-also_1","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / stateViewModel stateViewModel \u00b6 [android] Content inline fun < T : ViewModel > Fragment . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandle. The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels. [android] Content inline fun < T : ViewModel > ComponentActivity . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandle. The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"State view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-view-model/#stateviewmodel","text":"[android] Content inline fun < T : ViewModel > Fragment . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandle. The provider should instantiate the ViewModel directly.","title":"stateViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels. [android] Content inline fun < T : ViewModel > ComponentActivity . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > More info Creates a ViewModel with a SavedStateHandle. The provider should instantiate the ViewModel directly.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-view-model/#see-also_1","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/","text":"// reactivestate / com.ensody.reactivestate.android / BuildOnViewModelContext BuildOnViewModelContext \u00b6 [android] class BuildOnViewModelContext ( scope : CoroutineScope, stateFlowStore : StateFlowStore ) Build context for buildOnViewModel . Constructors \u00b6 BuildOnViewModelContext [android] fun BuildOnViewModelContext (scope: CoroutineScope, stateFlowStore: StateFlowStore ) Properties \u00b6 Name Summary scope [android] val scope : CoroutineScopeThe viewModelScope . stateFlowStore [android] val stateFlowStore : StateFlowStore A StateFlowStore where you can store/load the saved instance state (similar to a SavedStateHandle ).","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/#buildonviewmodelcontext","text":"[android] class BuildOnViewModelContext ( scope : CoroutineScope, stateFlowStore : StateFlowStore ) Build context for buildOnViewModel .","title":"BuildOnViewModelContext"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/#constructors","text":"BuildOnViewModelContext [android] fun BuildOnViewModelContext (scope: CoroutineScope, stateFlowStore: StateFlowStore )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/#properties","text":"Name Summary scope [android] val scope : CoroutineScopeThe viewModelScope . stateFlowStore [android] val stateFlowStore : StateFlowStore A StateFlowStore where you can store/load the saved instance state (similar to a SavedStateHandle ).","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/-build-on-view-model-context/","text":"// reactivestate / com.ensody.reactivestate.android / BuildOnViewModelContext / BuildOnViewModelContext BuildOnViewModelContext \u00b6 [android] Content fun BuildOnViewModelContext (scope: CoroutineScope, stateFlowStore: StateFlowStore )","title":" build on view model context"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/-build-on-view-model-context/#buildonviewmodelcontext","text":"[android] Content fun BuildOnViewModelContext (scope: CoroutineScope, stateFlowStore: StateFlowStore )","title":"BuildOnViewModelContext"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/scope/","text":"// reactivestate / com.ensody.reactivestate.android / BuildOnViewModelContext / scope scope \u00b6 [android] Content val scope : CoroutineScope More info The viewModelScope .","title":"Scope"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/scope/#scope","text":"[android] Content val scope : CoroutineScope More info The viewModelScope .","title":"scope"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/state-flow-store/","text":"// reactivestate / com.ensody.reactivestate.android / BuildOnViewModelContext / stateFlowStore stateFlowStore \u00b6 [android] Content val stateFlowStore : StateFlowStore More info A StateFlowStore where you can store/load the saved instance state (similar to a SavedStateHandle ).","title":"State flow store"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/state-flow-store/#stateflowstore","text":"[android] Content val stateFlowStore : StateFlowStore More info A StateFlowStore where you can store/load the saved instance state (similar to a SavedStateHandle ).","title":"stateFlowStore"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/","text":"// reactivestate / com.ensody.reactivestate.android / LifecycleCoroutineLauncher LifecycleCoroutineLauncher \u00b6 [android] class LifecycleCoroutineLauncher ( owner : LifecycleOwner ) : SimpleCoroutineLauncher A SimpleCoroutineLauncher that launches coroutines in the STARTED state. Constructors \u00b6 LifecycleCoroutineLauncher [android] fun LifecycleCoroutineLauncher (owner: LifecycleOwner ) Functions \u00b6 Name Summary launch Platforms: android open override fun launch (context: CoroutineContext , start: CoroutineStart, withLoading: MutableValueFlow < Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. onError Platforms: android open override fun onError (error: Throwable ) Properties \u00b6 Name Summary launcherScope [android] override val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [android] override val loading : MutableValueFlow < Int >The default loading tracker. owner [android] val owner : LifecycleOwner","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/#lifecyclecoroutinelauncher","text":"[android] class LifecycleCoroutineLauncher ( owner : LifecycleOwner ) : SimpleCoroutineLauncher A SimpleCoroutineLauncher that launches coroutines in the STARTED state.","title":"LifecycleCoroutineLauncher"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/#constructors","text":"LifecycleCoroutineLauncher [android] fun LifecycleCoroutineLauncher (owner: LifecycleOwner )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/#functions","text":"Name Summary launch Platforms: android open override fun launch (context: CoroutineContext , start: CoroutineStart, withLoading: MutableValueFlow < Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. onError Platforms: android open override fun onError (error: Throwable )","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/#properties","text":"Name Summary launcherScope [android] override val launcherScope : CoroutineScopeThe underlying CoroutineScope of this launcher. loading [android] override val loading : MutableValueFlow < Int >The default loading tracker. owner [android] val owner : LifecycleOwner","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/-lifecycle-coroutine-launcher/","text":"// reactivestate / com.ensody.reactivestate.android / LifecycleCoroutineLauncher / LifecycleCoroutineLauncher LifecycleCoroutineLauncher \u00b6 [android] Content fun LifecycleCoroutineLauncher (owner: LifecycleOwner )","title":" lifecycle coroutine launcher"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/-lifecycle-coroutine-launcher/#lifecyclecoroutinelauncher","text":"[android] Content fun LifecycleCoroutineLauncher (owner: LifecycleOwner )","title":"LifecycleCoroutineLauncher"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/on-error/","text":"// reactivestate / com.ensody.reactivestate.android / LifecycleCoroutineLauncher / onError onError \u00b6 [android] Content open override fun onError (error: Throwable )","title":"On error"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/on-error/#onerror","text":"[android] Content open override fun onError (error: Throwable )","title":"onError"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/owner/","text":"// reactivestate / com.ensody.reactivestate.android / LifecycleCoroutineLauncher / owner owner \u00b6 [android] Content val owner : LifecycleOwner","title":"Owner"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/owner/#owner","text":"[android] Content val owner : LifecycleOwner","title":"owner"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/","text":"// reactivestate / com.ensody.reactivestate.android / SavedStateHandleStore SavedStateHandleStore \u00b6 [android] class SavedStateHandleStore ( scope : CoroutineScope?, savedStateHandle : SavedStateHandle ) : StateFlowStore A StateFlowStore that wraps a SavedStateHandle . This can synchronize either two-way ([MutableValueFlow](../../com.ensody.reactivestate/-mutable-value-flow/index.md) < -> LiveData) if scope is not null one-way ([MutableValueFlow](../../com.ensody.reactivestate/-mutable-value-flow/index.md) -> LiveData) if scope is null Depending on whether you already have a scope Constructors \u00b6 SavedStateHandleStore [android] fun SavedStateHandleStore (savedStateHandle: SavedStateHandle )Wraps the given SavedStateHandle and synchronizes one-way from MutableValueFlow to LiveData. SavedStateHandleStore [android] fun SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle ) Functions \u00b6 Name Summary contains Platforms: android open operator override fun contains (key: String ): Boolean getData Platforms: android open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/#savedstatehandlestore","text":"[android] class SavedStateHandleStore ( scope : CoroutineScope?, savedStateHandle : SavedStateHandle ) : StateFlowStore A StateFlowStore that wraps a SavedStateHandle . This can synchronize either two-way ([MutableValueFlow](../../com.ensody.reactivestate/-mutable-value-flow/index.md) < -> LiveData) if scope is not null one-way ([MutableValueFlow](../../com.ensody.reactivestate/-mutable-value-flow/index.md) -> LiveData) if scope is null Depending on whether you already have a scope","title":"SavedStateHandleStore"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/#constructors","text":"SavedStateHandleStore [android] fun SavedStateHandleStore (savedStateHandle: SavedStateHandle )Wraps the given SavedStateHandle and synchronizes one-way from MutableValueFlow to LiveData. SavedStateHandleStore [android] fun SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/#functions","text":"Name Summary contains Platforms: android open operator override fun contains (key: String ): Boolean getData Platforms: android open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/-saved-state-handle-store/","text":"// reactivestate / com.ensody.reactivestate.android / SavedStateHandleStore / SavedStateHandleStore SavedStateHandleStore \u00b6 [android] Content fun SavedStateHandleStore (savedStateHandle: SavedStateHandle ) More info Wraps the given SavedStateHandle and synchronizes one-way from MutableValueFlow to LiveData. [android] Content fun SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle )","title":" saved state handle store"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/-saved-state-handle-store/#savedstatehandlestore","text":"[android] Content fun SavedStateHandleStore (savedStateHandle: SavedStateHandle ) More info Wraps the given SavedStateHandle and synchronizes one-way from MutableValueFlow to LiveData. [android] Content fun SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle )","title":"SavedStateHandleStore"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/contains/","text":"// reactivestate / com.ensody.reactivestate.android / SavedStateHandleStore / contains contains \u00b6 [android] Content open operator override fun contains (key: String ): Boolean","title":"Contains"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/contains/#contains","text":"[android] Content open operator override fun contains (key: String ): Boolean","title":"contains"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/get-data/","text":"// reactivestate / com.ensody.reactivestate.android / SavedStateHandleStore / getData getData \u00b6 [android] Content open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Get data"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/get-data/#getdata","text":"[android] Content open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"getData"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / WrapperViewModel WrapperViewModel \u00b6 [android] class WrapperViewModel ( stateFlowStore : StateFlowStore ) : ViewModel The wrapper ViewModel used by buildOnViewModel . Constructors \u00b6 WrapperViewModel [android] fun WrapperViewModel (stateFlowStore: StateFlowStore ) Functions \u00b6 Name Summary clear Platforms: android @ MainThread () fun clear () getTag Platforms: android open fun < T : Any > getTag (p0: String ): T onCleared Platforms: android open fun onCleared () setTagIfAbsent Platforms: android open fun < T : Any > setTagIfAbsent (p0: String , p1: T ): T Properties \u00b6 Name Summary registry [android] val registry : MutableMap < KClass <*>, Any > stateFlowStore [android] val stateFlowStore : StateFlowStore","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/#wrapperviewmodel","text":"[android] class WrapperViewModel ( stateFlowStore : StateFlowStore ) : ViewModel The wrapper ViewModel used by buildOnViewModel .","title":"WrapperViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/#constructors","text":"WrapperViewModel [android] fun WrapperViewModel (stateFlowStore: StateFlowStore )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/#functions","text":"Name Summary clear Platforms: android @ MainThread () fun clear () getTag Platforms: android open fun < T : Any > getTag (p0: String ): T onCleared Platforms: android open fun onCleared () setTagIfAbsent Platforms: android open fun < T : Any > setTagIfAbsent (p0: String , p1: T ): T","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/#properties","text":"Name Summary registry [android] val registry : MutableMap < KClass <*>, Any > stateFlowStore [android] val stateFlowStore : StateFlowStore","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/-wrapper-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / WrapperViewModel / WrapperViewModel WrapperViewModel \u00b6 [android] Content fun WrapperViewModel (stateFlowStore: StateFlowStore )","title":" wrapper view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/-wrapper-view-model/#wrapperviewmodel","text":"[android] Content fun WrapperViewModel (stateFlowStore: StateFlowStore )","title":"WrapperViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/registry/","text":"// reactivestate / com.ensody.reactivestate.android / WrapperViewModel / registry registry \u00b6 [android] Content val registry : MutableMap < KClass <*>, Any >","title":"Registry"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/registry/#registry","text":"[android] Content val registry : MutableMap < KClass <*>, Any >","title":"registry"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/state-flow-store/","text":"// reactivestate / com.ensody.reactivestate.android / WrapperViewModel / stateFlowStore stateFlowStore \u00b6 [android] Content val stateFlowStore : StateFlowStore","title":"State flow store"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/state-flow-store/#stateflowstore","text":"[android] Content val stateFlowStore : StateFlowStore","title":"stateFlowStore"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/","text":"// reactivestate-test / com.ensody.reactivestate.test Package com.ensody.reactivestate.test \u00b6 Types \u00b6 Name Summary CoroutineTest Platforms: jvm open class CoroutineTest : CoroutineTestRule , AttachedDisposables Base class for unit testing coroutine based code. CoroutineTestRule Platforms: jvm open class CoroutineTestRule Helper class for unit Tests that sets up dispatchers with a TestCoroutineDispatcherConfig on every test run. EventNotifierTest Platforms: jvm abstract class EventNotifierTest < E > : CoroutineTest Base class for unit testing an EventNotifier. ReactiveStateTest Platforms: jvm abstract class ReactiveStateTest < E : ErrorEvents> : EventNotifierTest < E > Base class for unit testing an EventNotifier. TestCoroutineDispatcherConfig Platforms: jvm class TestCoroutineDispatcherConfig ( dispatcher : TestCoroutineDispatcher) : CoroutineDispatcherConfig A CoroutineDispatcherConfig for unit tests - dispatching everything to the given dispatcher .","title":"reactivestate-test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/#package-comensodyreactivestatetest","text":"","title":"Package com.ensody.reactivestate.test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/#types","text":"Name Summary CoroutineTest Platforms: jvm open class CoroutineTest : CoroutineTestRule , AttachedDisposables Base class for unit testing coroutine based code. CoroutineTestRule Platforms: jvm open class CoroutineTestRule Helper class for unit Tests that sets up dispatchers with a TestCoroutineDispatcherConfig on every test run. EventNotifierTest Platforms: jvm abstract class EventNotifierTest < E > : CoroutineTest Base class for unit testing an EventNotifier. ReactiveStateTest Platforms: jvm abstract class ReactiveStateTest < E : ErrorEvents> : EventNotifierTest < E > Base class for unit testing an EventNotifier. TestCoroutineDispatcherConfig Platforms: jvm class TestCoroutineDispatcherConfig ( dispatcher : TestCoroutineDispatcher) : CoroutineDispatcherConfig A CoroutineDispatcherConfig for unit tests - dispatching everything to the given dispatcher .","title":"Types"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTest CoroutineTest \u00b6 [jvm] open class CoroutineTest : CoroutineTestRule , AttachedDisposables Base class for unit testing coroutine based code. On every test run this class automatically sets MainScope and dispatchers to use a TestCoroutineDispatcher. Internally, this uses a CoroutineTestRule which does the actual dispatchers and Dispatchers.setMain() setup. This allows accessing e.g. the testCoroutineScope in your @Before setup method. Moreover, this provides an attachedDisposables attribute and a collectFlow helper, so you can activate SharingStarted.WhileSubscribed based flows created with derived, for example. Constructors \u00b6 CoroutineTest [jvm] fun CoroutineTest () Functions \u00b6 Name Summary collectFlow Platforms: jvm fun < T > TestCoroutineScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose Platforms: jvm open override fun dispose () enterCoroutineTest Platforms: jvm fun enterCoroutineTest () exitCoroutineTest Platforms: jvm fun exitCoroutineTest () runBlockingTest Platforms: jvm open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) In addition to running the test this also disposes the attachedDisposables (useful with collectFlow ). Properties \u00b6 Name Summary attachedDisposables [jvm] open override val attachedDisposables : DisposableGroup testCoroutineDispatcher [jvm] val testCoroutineDispatcher : TestCoroutineDispatcher testCoroutineScope [jvm] val testCoroutineScope : TestCoroutineScope Inheritors \u00b6 Name EventNotifierTest","title":"Index"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/#coroutinetest","text":"[jvm] open class CoroutineTest : CoroutineTestRule , AttachedDisposables Base class for unit testing coroutine based code. On every test run this class automatically sets MainScope and dispatchers to use a TestCoroutineDispatcher. Internally, this uses a CoroutineTestRule which does the actual dispatchers and Dispatchers.setMain() setup. This allows accessing e.g. the testCoroutineScope in your @Before setup method. Moreover, this provides an attachedDisposables attribute and a collectFlow helper, so you can activate SharingStarted.WhileSubscribed based flows created with derived, for example.","title":"CoroutineTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/#constructors","text":"CoroutineTest [jvm] fun CoroutineTest ()","title":"Constructors"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/#functions","text":"Name Summary collectFlow Platforms: jvm fun < T > TestCoroutineScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose Platforms: jvm open override fun dispose () enterCoroutineTest Platforms: jvm fun enterCoroutineTest () exitCoroutineTest Platforms: jvm fun exitCoroutineTest () runBlockingTest Platforms: jvm open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) In addition to running the test this also disposes the attachedDisposables (useful with collectFlow ).","title":"Functions"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/#properties","text":"Name Summary attachedDisposables [jvm] open override val attachedDisposables : DisposableGroup testCoroutineDispatcher [jvm] val testCoroutineDispatcher : TestCoroutineDispatcher testCoroutineScope [jvm] val testCoroutineScope : TestCoroutineScope","title":"Properties"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/#inheritors","text":"Name EventNotifierTest","title":"Inheritors"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/-coroutine-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTest / CoroutineTest CoroutineTest \u00b6 [jvm] Content fun CoroutineTest ()","title":" coroutine test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/-coroutine-test/#coroutinetest","text":"[jvm] Content fun CoroutineTest ()","title":"CoroutineTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/attached-disposables/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTest / attachedDisposables attachedDisposables \u00b6 [jvm] Content open override val attachedDisposables : DisposableGroup","title":"Attached disposables"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/attached-disposables/#attacheddisposables","text":"[jvm] Content open override val attachedDisposables : DisposableGroup","title":"attachedDisposables"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/collect-flow/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTest / collectFlow collectFlow \u00b6 [jvm] Content fun < T > TestCoroutineScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) More info Collects a flow in the background.","title":"Collect flow"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/collect-flow/#collectflow","text":"[jvm] Content fun < T > TestCoroutineScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) More info Collects a flow in the background.","title":"collectFlow"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/run-blocking-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTest / runBlockingTest runBlockingTest \u00b6 [jvm] Content open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) More info In addition to running the test this also disposes the attachedDisposables (useful with collectFlow ).","title":"Run blocking test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test/run-blocking-test/#runblockingtest","text":"[jvm] Content open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) More info In addition to running the test this also disposes the attachedDisposables (useful with collectFlow ).","title":"runBlockingTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTestRule CoroutineTestRule \u00b6 [jvm] open class CoroutineTestRule Helper class for unit Tests that sets up dispatchers with a TestCoroutineDispatcherConfig on every test run. Also, Dispatchers.Main is set to a TestCoroutineScope. This rule allows for e.g. setup methods with @Before which need access to the TestCoroutineScope. Use the runBlockingTest method provided by this rule instead of the one provided by the coroutines library. You can also access the testCoroutineScope and testCoroutineDispatcher in case you need them to e.g. launch some background process during each test. Constructors \u00b6 CoroutineTestRule [jvm] fun CoroutineTestRule () Functions \u00b6 Name Summary enterCoroutineTest Platforms: jvm fun enterCoroutineTest () exitCoroutineTest Platforms: jvm fun exitCoroutineTest () runBlockingTest Platforms: jvm open fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) Properties \u00b6 Name Summary testCoroutineDispatcher [jvm] val testCoroutineDispatcher : TestCoroutineDispatcher testCoroutineScope [jvm] val testCoroutineScope : TestCoroutineScope Inheritors \u00b6 Name CoroutineTest","title":"Index"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/#coroutinetestrule","text":"[jvm] open class CoroutineTestRule Helper class for unit Tests that sets up dispatchers with a TestCoroutineDispatcherConfig on every test run. Also, Dispatchers.Main is set to a TestCoroutineScope. This rule allows for e.g. setup methods with @Before which need access to the TestCoroutineScope. Use the runBlockingTest method provided by this rule instead of the one provided by the coroutines library. You can also access the testCoroutineScope and testCoroutineDispatcher in case you need them to e.g. launch some background process during each test.","title":"CoroutineTestRule"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/#constructors","text":"CoroutineTestRule [jvm] fun CoroutineTestRule ()","title":"Constructors"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/#functions","text":"Name Summary enterCoroutineTest Platforms: jvm fun enterCoroutineTest () exitCoroutineTest Platforms: jvm fun exitCoroutineTest () runBlockingTest Platforms: jvm open fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit )","title":"Functions"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/#properties","text":"Name Summary testCoroutineDispatcher [jvm] val testCoroutineDispatcher : TestCoroutineDispatcher testCoroutineScope [jvm] val testCoroutineScope : TestCoroutineScope","title":"Properties"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/#inheritors","text":"Name CoroutineTest","title":"Inheritors"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/-coroutine-test-rule/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTestRule / CoroutineTestRule CoroutineTestRule \u00b6 [jvm] Content fun CoroutineTestRule ()","title":" coroutine test rule"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/-coroutine-test-rule/#coroutinetestrule","text":"[jvm] Content fun CoroutineTestRule ()","title":"CoroutineTestRule"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/enter-coroutine-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTestRule / enterCoroutineTest enterCoroutineTest \u00b6 [jvm] Content fun enterCoroutineTest ()","title":"Enter coroutine test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/enter-coroutine-test/#entercoroutinetest","text":"[jvm] Content fun enterCoroutineTest ()","title":"enterCoroutineTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/exit-coroutine-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTestRule / exitCoroutineTest exitCoroutineTest \u00b6 [jvm] Content fun exitCoroutineTest ()","title":"Exit coroutine test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/exit-coroutine-test/#exitcoroutinetest","text":"[jvm] Content fun exitCoroutineTest ()","title":"exitCoroutineTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/run-blocking-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTestRule / runBlockingTest runBlockingTest \u00b6 [jvm] Content open fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit )","title":"Run blocking test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/run-blocking-test/#runblockingtest","text":"[jvm] Content open fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit )","title":"runBlockingTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-dispatcher/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTestRule / testCoroutineDispatcher testCoroutineDispatcher \u00b6 [jvm] Content val testCoroutineDispatcher : TestCoroutineDispatcher","title":"Test coroutine dispatcher"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-dispatcher/#testcoroutinedispatcher","text":"[jvm] Content val testCoroutineDispatcher : TestCoroutineDispatcher","title":"testCoroutineDispatcher"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-scope/","text":"// reactivestate-test / com.ensody.reactivestate.test / CoroutineTestRule / testCoroutineScope testCoroutineScope \u00b6 [jvm] Content val testCoroutineScope : TestCoroutineScope","title":"Test coroutine scope"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-scope/#testcoroutinescope","text":"[jvm] Content val testCoroutineScope : TestCoroutineScope","title":"testCoroutineScope"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / EventNotifierTest EventNotifierTest \u00b6 [jvm] abstract class EventNotifierTest < E > : CoroutineTest Base class for unit testing an EventNotifier. You have to override the eventNotifier and events attributes. Usually, events will be a mock. By default this handles events in runBlockingTest . You can disable this by overriding handleEventsInRunBlockingTest to false. In that case you have to explicitly call handleEvents in each test. Constructors \u00b6 EventNotifierTest [jvm] fun EventNotifierTest () Functions \u00b6 Name Summary collectFlow Platforms: jvm fun < T > TestCoroutineScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose Platforms: jvm open override fun dispose () enterCoroutineTest Platforms: jvm fun enterCoroutineTest () exitCoroutineTest Platforms: jvm fun exitCoroutineTest () handleEvents Platforms: jvm fun handleEvents () runBlockingTest Platforms: jvm open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) In addition to running the test this also disposes the attachedDisposables (useful with collectFlow). Properties \u00b6 Name Summary attachedDisposables [jvm] open override val attachedDisposables : DisposableGroup eventNotifier [jvm] abstract val eventNotifier : EventNotifier< E > events [jvm] abstract val events : E handleEventsInRunBlockingTest [jvm] open val handleEventsInRunBlockingTest : Boolean = true testCoroutineDispatcher [jvm] val testCoroutineDispatcher : TestCoroutineDispatcher testCoroutineScope [jvm] val testCoroutineScope : TestCoroutineScope Inheritors \u00b6 Name ReactiveStateTest","title":"Index"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/#eventnotifiertest","text":"[jvm] abstract class EventNotifierTest < E > : CoroutineTest Base class for unit testing an EventNotifier. You have to override the eventNotifier and events attributes. Usually, events will be a mock. By default this handles events in runBlockingTest . You can disable this by overriding handleEventsInRunBlockingTest to false. In that case you have to explicitly call handleEvents in each test.","title":"EventNotifierTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/#constructors","text":"EventNotifierTest [jvm] fun EventNotifierTest ()","title":"Constructors"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/#functions","text":"Name Summary collectFlow Platforms: jvm fun < T > TestCoroutineScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose Platforms: jvm open override fun dispose () enterCoroutineTest Platforms: jvm fun enterCoroutineTest () exitCoroutineTest Platforms: jvm fun exitCoroutineTest () handleEvents Platforms: jvm fun handleEvents () runBlockingTest Platforms: jvm open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) In addition to running the test this also disposes the attachedDisposables (useful with collectFlow).","title":"Functions"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/#properties","text":"Name Summary attachedDisposables [jvm] open override val attachedDisposables : DisposableGroup eventNotifier [jvm] abstract val eventNotifier : EventNotifier< E > events [jvm] abstract val events : E handleEventsInRunBlockingTest [jvm] open val handleEventsInRunBlockingTest : Boolean = true testCoroutineDispatcher [jvm] val testCoroutineDispatcher : TestCoroutineDispatcher testCoroutineScope [jvm] val testCoroutineScope : TestCoroutineScope","title":"Properties"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/#inheritors","text":"Name ReactiveStateTest","title":"Inheritors"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/-event-notifier-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / EventNotifierTest / EventNotifierTest EventNotifierTest \u00b6 [jvm] Content fun EventNotifierTest ()","title":" event notifier test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/-event-notifier-test/#eventnotifiertest","text":"[jvm] Content fun EventNotifierTest ()","title":"EventNotifierTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/event-notifier/","text":"// reactivestate-test / com.ensody.reactivestate.test / EventNotifierTest / eventNotifier eventNotifier \u00b6 [jvm] Content abstract val eventNotifier : EventNotifier< E >","title":"Event notifier"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/event-notifier/#eventnotifier","text":"[jvm] Content abstract val eventNotifier : EventNotifier< E >","title":"eventNotifier"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/events/","text":"// reactivestate-test / com.ensody.reactivestate.test / EventNotifierTest / events events \u00b6 [jvm] Content abstract val events : E","title":"Events"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/events/#events","text":"[jvm] Content abstract val events : E","title":"events"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/handle-events-in-run-blocking-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / EventNotifierTest / handleEventsInRunBlockingTest handleEventsInRunBlockingTest \u00b6 [jvm] Content open val handleEventsInRunBlockingTest : Boolean = true","title":"Handle events in run blocking test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/handle-events-in-run-blocking-test/#handleeventsinrunblockingtest","text":"[jvm] Content open val handleEventsInRunBlockingTest : Boolean = true","title":"handleEventsInRunBlockingTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/handle-events/","text":"// reactivestate-test / com.ensody.reactivestate.test / EventNotifierTest / handleEvents handleEvents \u00b6 [jvm] Content fun handleEvents ()","title":"Handle events"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/handle-events/#handleevents","text":"[jvm] Content fun handleEvents ()","title":"handleEvents"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/run-blocking-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / EventNotifierTest / runBlockingTest runBlockingTest \u00b6 [jvm] Content open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) More info In addition to running the test this also disposes the attachedDisposables (useful with collectFlow).","title":"Run blocking test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-event-notifier-test/run-blocking-test/#runblockingtest","text":"[jvm] Content open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) More info In addition to running the test this also disposes the attachedDisposables (useful with collectFlow).","title":"runBlockingTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / ReactiveStateTest ReactiveStateTest \u00b6 [jvm] abstract class ReactiveStateTest < E : ErrorEvents> : EventNotifierTest < E > Base class for unit testing an EventNotifier. You have to override the eventNotifier and events attributes. Usually, events will be a mock. By default this handles events in runBlockingTest. You can disable this by overriding handleEventsInRunBlockingTest to false. In that case you have to explicitly call handleEvents in each test. Constructors \u00b6 ReactiveStateTest [jvm] fun ReactiveStateTest () Functions \u00b6 Name Summary collectFlow Platforms: jvm fun < T > TestCoroutineScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose Platforms: jvm open override fun dispose () enterCoroutineTest Platforms: jvm fun enterCoroutineTest () exitCoroutineTest Platforms: jvm fun exitCoroutineTest () handleEvents Platforms: jvm fun handleEvents () runBlockingTest Platforms: jvm open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) In addition to running the test this also disposes the attachedDisposables (useful with collectFlow). Properties \u00b6 Name Summary attachedDisposables [jvm] open override val attachedDisposables : DisposableGroup eventNotifier [jvm] open override val eventNotifier : EventNotifier< E > events [jvm] abstract val events : E handleEventsInRunBlockingTest [jvm] open val handleEventsInRunBlockingTest : Boolean reactiveState [jvm] abstract val reactiveState : ReactiveState< E > testCoroutineDispatcher [jvm] val testCoroutineDispatcher : TestCoroutineDispatcher testCoroutineScope [jvm] val testCoroutineScope : TestCoroutineScope","title":"Index"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/#reactivestatetest","text":"[jvm] abstract class ReactiveStateTest < E : ErrorEvents> : EventNotifierTest < E > Base class for unit testing an EventNotifier. You have to override the eventNotifier and events attributes. Usually, events will be a mock. By default this handles events in runBlockingTest. You can disable this by overriding handleEventsInRunBlockingTest to false. In that case you have to explicitly call handleEvents in each test.","title":"ReactiveStateTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/#constructors","text":"ReactiveStateTest [jvm] fun ReactiveStateTest ()","title":"Constructors"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/#functions","text":"Name Summary collectFlow Platforms: jvm fun < T > TestCoroutineScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose Platforms: jvm open override fun dispose () enterCoroutineTest Platforms: jvm fun enterCoroutineTest () exitCoroutineTest Platforms: jvm fun exitCoroutineTest () handleEvents Platforms: jvm fun handleEvents () runBlockingTest Platforms: jvm open override fun runBlockingTest (block: suspend TestCoroutineScope.() -> Unit ) In addition to running the test this also disposes the attachedDisposables (useful with collectFlow).","title":"Functions"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/#properties","text":"Name Summary attachedDisposables [jvm] open override val attachedDisposables : DisposableGroup eventNotifier [jvm] open override val eventNotifier : EventNotifier< E > events [jvm] abstract val events : E handleEventsInRunBlockingTest [jvm] open val handleEventsInRunBlockingTest : Boolean reactiveState [jvm] abstract val reactiveState : ReactiveState< E > testCoroutineDispatcher [jvm] val testCoroutineDispatcher : TestCoroutineDispatcher testCoroutineScope [jvm] val testCoroutineScope : TestCoroutineScope","title":"Properties"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/-reactive-state-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / ReactiveStateTest / ReactiveStateTest ReactiveStateTest \u00b6 [jvm] Content fun ReactiveStateTest ()","title":" reactive state test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/-reactive-state-test/#reactivestatetest","text":"[jvm] Content fun ReactiveStateTest ()","title":"ReactiveStateTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/event-notifier/","text":"// reactivestate-test / com.ensody.reactivestate.test / ReactiveStateTest / eventNotifier eventNotifier \u00b6 [jvm] Content open override val eventNotifier : EventNotifier< E >","title":"Event notifier"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/event-notifier/#eventnotifier","text":"[jvm] Content open override val eventNotifier : EventNotifier< E >","title":"eventNotifier"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/reactive-state/","text":"// reactivestate-test / com.ensody.reactivestate.test / ReactiveStateTest / reactiveState reactiveState \u00b6 [jvm] Content abstract val reactiveState : ReactiveState< E >","title":"Reactive state"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-reactive-state-test/reactive-state/#reactivestate","text":"[jvm] Content abstract val reactiveState : ReactiveState< E >","title":"reactiveState"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/","text":"// reactivestate-test / com.ensody.reactivestate.test / TestCoroutineDispatcherConfig TestCoroutineDispatcherConfig \u00b6 [jvm] class TestCoroutineDispatcherConfig ( dispatcher : TestCoroutineDispatcher) : CoroutineDispatcherConfig A CoroutineDispatcherConfig for unit tests - dispatching everything to the given dispatcher . Constructors \u00b6 TestCoroutineDispatcherConfig [jvm] fun TestCoroutineDispatcherConfig (dispatcher: TestCoroutineDispatcher) Properties \u00b6 Name Summary default [jvm] open override val default : TestCoroutineDispatcher dispatcher [jvm] val dispatcher : TestCoroutineDispatcher io [jvm] open override val io : TestCoroutineDispatcher main [jvm] open override val main : TestCoroutineDispatcher unconfined [jvm] open override val unconfined : TestCoroutineDispatcher","title":"Index"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/#testcoroutinedispatcherconfig","text":"[jvm] class TestCoroutineDispatcherConfig ( dispatcher : TestCoroutineDispatcher) : CoroutineDispatcherConfig A CoroutineDispatcherConfig for unit tests - dispatching everything to the given dispatcher .","title":"TestCoroutineDispatcherConfig"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/#constructors","text":"TestCoroutineDispatcherConfig [jvm] fun TestCoroutineDispatcherConfig (dispatcher: TestCoroutineDispatcher)","title":"Constructors"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/#properties","text":"Name Summary default [jvm] open override val default : TestCoroutineDispatcher dispatcher [jvm] val dispatcher : TestCoroutineDispatcher io [jvm] open override val io : TestCoroutineDispatcher main [jvm] open override val main : TestCoroutineDispatcher unconfined [jvm] open override val unconfined : TestCoroutineDispatcher","title":"Properties"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/-test-coroutine-dispatcher-config/","text":"// reactivestate-test / com.ensody.reactivestate.test / TestCoroutineDispatcherConfig / TestCoroutineDispatcherConfig TestCoroutineDispatcherConfig \u00b6 [jvm] Content fun TestCoroutineDispatcherConfig (dispatcher: TestCoroutineDispatcher)","title":" test coroutine dispatcher config"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/-test-coroutine-dispatcher-config/#testcoroutinedispatcherconfig","text":"[jvm] Content fun TestCoroutineDispatcherConfig (dispatcher: TestCoroutineDispatcher)","title":"TestCoroutineDispatcherConfig"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/default/","text":"// reactivestate-test / com.ensody.reactivestate.test / TestCoroutineDispatcherConfig / default default \u00b6 [jvm] Content open override val default : TestCoroutineDispatcher","title":"Default"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/default/#default","text":"[jvm] Content open override val default : TestCoroutineDispatcher","title":"default"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/dispatcher/","text":"// reactivestate-test / com.ensody.reactivestate.test / TestCoroutineDispatcherConfig / dispatcher dispatcher \u00b6 [jvm] Content val dispatcher : TestCoroutineDispatcher","title":"Dispatcher"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/dispatcher/#dispatcher","text":"[jvm] Content val dispatcher : TestCoroutineDispatcher","title":"dispatcher"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/io/","text":"// reactivestate-test / com.ensody.reactivestate.test / TestCoroutineDispatcherConfig / io io \u00b6 [jvm] Content open override val io : TestCoroutineDispatcher","title":"Io"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/io/#io","text":"[jvm] Content open override val io : TestCoroutineDispatcher","title":"io"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/main/","text":"// reactivestate-test / com.ensody.reactivestate.test / TestCoroutineDispatcherConfig / main main \u00b6 [jvm] Content open override val main : TestCoroutineDispatcher","title":"Main"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/main/#main","text":"[jvm] Content open override val main : TestCoroutineDispatcher","title":"main"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/unconfined/","text":"// reactivestate-test / com.ensody.reactivestate.test / TestCoroutineDispatcherConfig / unconfined unconfined \u00b6 [jvm] Content open override val unconfined : TestCoroutineDispatcher","title":"Unconfined"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-test-coroutine-dispatcher-config/unconfined/#unconfined","text":"[jvm] Content open override val unconfined : TestCoroutineDispatcher","title":"unconfined"}]}